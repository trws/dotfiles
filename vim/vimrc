function! FindOrCreate(dir)
  if !isdirectory(expand(a:dir))
    call mkdir(expand(a:dir), "p")
  endif
endfunction

" Deal with single home/multi-arch systems
let plugged_directory = substitute(system("uname -m"), '[ \n]\+$', '', '')
if plugged_directory == "x86_64"
  let plugged_directory = ""
endif
let plugged_directory = "~/.cache/vim-plugged/" . plugged_directory
if !isdirectory(expand(plugged_directory))
  echo('fetching plug for initial install')
  call system('curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim')
  call system('mkdir -p ' . plugged_directory)
endif

call plug#begin(expand(plugged_directory))

" Bundle 'Shougo/vimproc.vim'
Plug 'Shougo/vimproc.vim' , { 'do' : 'make'}

"split management
Plug 'wesQ3/vim-windowswap'
let g:windowswap_map_keys = 0 "prevent default bindings
nnoremap <silent> <leader>wy :call WindowSwap#MarkWindowSwap()<CR>
nnoremap <silent> <leader>wp :call WindowSwap#DoWindowSwap()<CR>
nnoremap <silent> <leader>ws :call WindowSwap#EasyWindowSwap()<CR>

"Mail search
" Plug 'daisuzu/unite-notmuch'
" Plug 'diefans/notmuch-vim'

" let g:bracketed_paste_tmux_wrap=0
" Plug 'ConradIrwin/vim-bracketed-paste'

"colorschemes
" Plug 'tomasr/molokai'
" Plug 'sjl/badwolf'
" Plug 'Solarized'
" Plug 'github-theme'
Plug 'crusoexia/vim-monokai'
Plug 'nanotech/jellybeans.vim'

Plug 'greymd/oscyank.vim'  " clipboard support for xterm-type terms

Plug 'luochen1990/rainbow' " rainbow parens and braces etc.

" Render man pages in vim
Plug 'vim-utils/vim-man'

Plug 'dhruvasagar/vim-table-mode'

"visual
"Plug 'Powerline'
"powerline not working, light alternative?
Plug 'bling/vim-airline'
" Plug 'tomtom/quickfixsigns_vim'
" Plug 'bling/vim-bufferline'
" Plug 'edkolev/tmuxline.vim'

if executable('task')
  Plug 'blindFS/vim-taskwarrior'
endif
" support for live wrapping
Plug 'reedes/vim-pencil'

" ==== filetype handlers, highlighting etc ====
Plug 'sheerun/vim-polyglot' " pulls in syntax for almost everything
let g:polyglot_disabled = ['latex', 'markdown']
Plug 'chrisbra/vim-zsh'
let g:zsh_fold_enable = 1
Plug 'lervag/vimtex'
let g:vimtex_view_method='skim'
let g:vimtex_syntax_minted = [
      \ {
      \   'lang' : 'c',
      \ },
      \ {
      \   'lang' : 'cpp',
      \   'environments' : ['cppcode', 'cppcode_test'],
      \ },
      \ {
      \   'lang' : 'python',
      \   'ignore' : [
      \     'pythonEscape',
      \     'pythonBEscape',
      \     ],
      \ }
      \]
Plug 'tpope/vim-markdown'
let g:markdown_fenced_languages = ['html', 'python', 'bash=sh', "c", "c++=cpp", "latex=tex"]

function! RemovedForPolyglot()
" Plug 'jaxbot/semantic-highlight.vim'
" in polyglot - trying something new though Plug 'LaTeX-Box-Team/LaTeX-Box', { 'for' : ['latex', 'tex', 'bibtex']}
" Plug 'vim-latex'
" Plug 'vim-latex/vim-latex'
" Plug 'tpope/vim-liquid'
"c++11 highlighting
" Plug 'vim-jp/cpp-vim'
" Plug 'JuliaLang/julia-vim'
" Plug 'keith/swift.vim'
"rust highlighting
" Plug 'wting/rust.vim'
" Plug 'wavded/vim-stylus'
" Plug 'digitaltoad/vim-jade'
" map <silent> <buffer> <C-A-K> <Plug>VO_FollowLink
" Plug 'VimOutliner'
endfunction

function! InGui()
    return has("gui_running") || exists("g:gui_oni") || exists("neovim_dot_app") || has("gui_vimr")
endfunction


Plug 'mrtazz/DoxygenToolkit.vim'
"link handler
Plug 'vim-scripts/utl.vim'
" not in polyglot - cool csv highlighting
Plug 'chrisbra/csv.vim'
" CSupport plugin: XXX: reacts badly with several others
" Plug 'c.vim'
" org-mode
" Plug 'jceb/vim-orgmode'
" Plug 'dhruvasagar/vim-dotoo' " not really working...

" date incrementing with ^a and so-forth
Plug 'tpope/vim-speeddating'

"tmux integration
Plug 'vim-scripts/vimux'

if ! has('win32')
  function! BuildYCM(info)
    " info is a dictionary with 3 fields
    " - name:   name of the plugin
    " - status: 'installed', 'updated', or 'unchanged'
    " - force:  set on PlugInstall! or PlugUpdate!
    if a:info.status != 'unchanged'
      !./install.py --clang-completer
    endif
  endfunction

  Plug 'Valloric/YouCompleteMe', { 'do': function('BuildYCM') }
endif

" Plug 'jeaye/color_coded'

" Plug 'klen/python-mode'

function! JediDisabled()
" Plug 'davidhalter/jedi-vim'
let g:jedi#auto_vim_configuration = 0
let g:jedi#popup_on_dot = 0
let g:jedi#popup_select_first = 0
let g:jedi#completions_enabled = 0
let g:jedi#completions_command = ""
let g:jedi#show_call_signatures = "1"

let g:jedi#goto_assignments_command = "<leader>pa"
let g:jedi#goto_definitions_command = "<leader>pd"
let g:jedi#documentation_command = "<leader>pk"
let g:jedi#usages_command = "<leader>pu"
let g:jedi#rename_command = "<leader>pr"
endfunction

" Plug 'scrooloose/syntastic'

"project management
" Plug 'project.tar.gz'

"bindings

"shell/terminal emulation
" Plug 'Shougo/vimshell.vim', {'on' : 'VimShell'}
" Plug 'pthrasher/conqueterm-vim', {'on' : 'ConqueTerm'}

"file management
Plug 'xolox/vim-misc'
Plug 'xolox/vim-notes'
Plug 'vimwiki/vimwiki'
let wiki = {}
let wiki.path = expand('~/projects/vimwiki/')
let wiki.syntax = 'markdown'
let wiki.ext = '.md'
let wiki.nested_syntaxes = {'python': 'python', 'c++': 'cpp', 'c': 'c'}
let tasks = {}
let tasks.path = expand('~/projects/todo/')
let tasks.syntax = 'vimwiki'
let tasks.ext = '.wiki'
let tasks.nested_syntaxes = {'python': 'python', 'c++': 'cpp', 'c': 'c'}
let g:vimwiki_list = [wiki, tasks]
let g:vimwiki_global_ext=0
let g:vimwiki_folding=1
"outliner checkboxes
augroup filetype_vimwiki
  autocmd!
  au FileType vimwiki nmap <Leader>we <Plug>VimwikiSplitLink
  au FileType vimwiki nmap <Leader>wf <Plug>VimwikiFollowLink
  au FileType vimwiki nmap <Leader>wq <Plug>VimwikiVSplitLink
augroup END

" nasty deps, only works with vimwiki syntax not markdown for now,
" cool, but currently not quite what I want I think
" Plug 'tbabej/taskwiki'

Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
Plug 'junegunn/fzf.vim'
if(has("python3"))
  Plug 'Shougo/denite.nvim'
  Plug 'ozelentok/denite-gtags'
  Plug 'nixprime/cpsm'
endif
Plug 'Shougo/unite.vim'
Plug 'Shougo/vimfiler.vim'
Plug 'Shougo/unite-ssh'
Plug 'hewes/unite-gtags'
Plug 'tsukkee/unite-tag'
Plug 'Shougo/neoyank.vim' " provides history/yank unite source
Plug 'vim-scripts/gtags.vim'
Plug 'ludovicchabant/vim-gutentags'
" These are nice, but they are *way* too slow
" Plug 'xolox/vim-misc'
" Plug 'xolox/vim-easytags'
" NeoBundleLazy 'ujihisa/vimshell-ssh', { 'autoload' : {
"             \ 'filetypes' : 'vimshell',
"             \ }}
Plug 'Shougo/neomru.vim'

if (! exists("g:gui_oni"))
  "ctrlp
  Plug 'kien/ctrlp.vim'
  let g:ctrlp_working_path_mode = 'ra'
  let g:ctrlp_extensions = ['tag', 'buffertag', 'quickfix', 'dir', 'rtscript',
        \ 'undo', 'line', 'changes', 'mixed', 'bookmarkdir']
  " let g:ctrlp_extensions = ['tag', 'buffertag', 'quickfix', 'changes', 'mixed', 'bookmarkdir']
endif

Plug 'tpope/vim-fugitive'
"
" cmdline-mode mappings
Plug 'tpope/vim-rsi'
" Plug 'critiqjo/husk-x.vim'

" Plug 'airblade/vim-gitgutter'

Plug 'nathanaelkane/vim-indent-guides'
let g:indent_guides_start_level = 2
let g:indent_guides_guide_size = 1
let g:indent_guides_enable_on_vim_startup = 1

Plug 'terryma/vim-multiple-cursors'


" Plug 'Raimondi/delimitMate'
Plug 'tpope/vim-surround'
Plug 'tommcdo/vim-exchange'
Plug 'SirVer/ultisnips'
" Snippets are separated from the engine. Add this if you want them:
Plug 'honza/vim-snippets'
Plug 'Lokaltog/vim-easymotion'
" map <Leader>e <Plug>(easymotion-prefix)
" Plug 'The-NERD-Commenter'
Plug 'majutsushi/tagbar'
Plug 'Chiel92/vim-autoformat'
Plug 'sjl/gundo.vim'
Plug 'tpope/vim-repeat'
Plug 'vim-scripts/visualrepeat'
"new alignment plugin, CR from visual mode to use
Plug 'junegunn/vim-easy-align'
Plug 'tpope/vim-abolish'
" Plug 'tpope/vim-pastie'
"Unix command aliases, Chmod and company
Plug 'tpope/vim-eunuch'
Plug 'tpope/vim-unimpaired'
Plug 'tpope/vim-dispatch'
Plug 'radenling/vim-dispatch-neovim'
Plug 'tomtom/tcomment_vim'
"Word highlighting for possible but uncertain errors
Plug 'reedes/vim-wordy'

call plug#end()

let mapleader      = ','
let maplocalleader = ','


runtime! macros/matchit.vim

"Alignment mapping to enter in visual mode
vmap <CR> <Plug>(EasyAlign)

" let $PYTHONPATH .= ":~/.vim/included/ropevim"
" source ~/.vim/included/ropevim/ropevim.vim

"make command mode suck less, mimic a shell
" start of line
:cnoremap <C-A>         <Home>
" back one character
:cnoremap <C-B>         <Left>
" delete character under cursor
:cnoremap <C-D>         <Del>
" end of line
:cnoremap <C-E>         <End>
" forward one character
:cnoremap <C-F>         <Right>
" recall newer command-line
" :cnoremap <C-N>               <Down>
" recall previous (older) command-line
" :cnoremap <C-P>               <Up>
" back one word
" :cnoremap <Esc><B>    <S-Left>
" forward one word
" :cnoremap <Esc><F>    <S-Right>

" Prompt for a command to run
map <Leader>vp :VimuxPromptCommand<CR>

" Open pane
map <Leader>vo :call VimuxOpenPane()<CR>

" Run last command executed by VimuxRunCommand
map <Leader>vl :VimuxRunLastCommand<CR>

" Inspect runner pane
map <Leader>vi :VimuxInspectRunner<CR>

" Close vim tmux runner opened by VimuxRunCommand
map <Leader>vq :VimuxCloseRunner<CR>

" Interrupt any command running in the runner pane
map <Leader>vx :VimuxInterruptRunner<CR>


"" add neocomplcache option
"let g:neocomplcache_force_overwrite_completefunc=1

"let g:neocomplcache_enable_at_startup = 1
"let g:neocomplcache_disable_auto_complete = 1
"" Plugin key-mappings.
"imap <C-k>     <Plug>(neosnippet_expand_or_jump)
"smap <C-k>     <Plug>(neosnippet_expand_or_jump)

"" SuperTab like snippets behavior.
"imap <expr><TAB> neosnippet#expandable() <Bar><bar> neosnippet#jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : pumvisible() ? "\<C-n>" : "\<TAB>"
"smap <expr><TAB> neosnippet#expandable() <Bar><bar> neosnippet#jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"
"inoremap <expr><Tab>  neocomplcache#start_manual_complete()

"" For snippet_complete marker.
"let g:neosnippet#snippets_directory="~/.vim/included-old/snipmate/snippets/"
"if has('conceal')
"set conceallevel=2 concealcursor=i
"endif

"Unite and denite
let g:unite_data_directory = '~/.vim/unite'
" let g:unite_source_bookmark_directory = '~/.vim/unite-bookmarks'
let g:unite_source_history_yank_enable = 1
let g:unite_source_vimshell_external_history_path="~/.zsh-history:~/.zsh-history-$HOST"
let g:unite_source_grep_max_candidates = 500
call unite#filters#matcher_default#use(['converter_relative_word', 'matcher_fuzzy'])
call unite#filters#sorter_default#use(['sorter_rank'])
call unite#custom#profile('files', 'filters', 'sorter_rank')
call unite#custom#source('buffer,file,file_rec,file_rec/async', 'sorters', 'sorter_selecta')
call unite#custom#source('buffer,file,file_rec,file_rec/async', 'matchers',['converter_relative_word', 'matcher_fuzzy'])
let  g:notes_directories = ['~/Projects/notes']
if( ! has("python3")) " using unite
  nnoremap <leader>ur  :<C-u>Unite -start-insert file_rec/async:!<CR>
  nnoremap <leader>ub  :<C-u>Unite buffer        file_mru bookmark<CR>
  nnoremap <leader>uB  :<C-u>Unite bookmark<CR>
  nnoremap <leader>uY  :<C-u>Unite history/yank<CR>
  nnoremap <leader>uf  :<C-u>Unite -start-insert file<CR>
  nnoremap <leader>un  :<C-u>Unite -start-insert file_rec:~/Projects/notes/<CR>
  nnoremap <leader>ug  :<C-u>Unite grep:.<CR>
  nnoremap <leader>uG  :<C-u>Unite grep:.:-i<CR>
  nnoremap <leader>utc :<C-u>Unite gtags/context<CR>
  nnoremap <leader>utr :<C-u>Unite gtags/ref<CR>
  nnoremap <leader>utd :<C-u>Unite gtags/def<CR>
  nnoremap <leader>utg :<C-u>Unite gtags/grep<CR>
  nnoremap <leader>utf :<C-u>Unite gtags/file<CR>
  nnoremap <leader>utC :<C-u>Unite gtags/completion<CR>
else
  call denite#custom#alias('source', 'file_rec/git', 'file_rec')
  call denite#custom#var('file_rec/git', 'command',
        \ ['git', 'ls-files', '-co', '--exclude-standard'])
  nnoremap <silent> <leader>ur :<C-u>Denite
        \ `finddir('.git', ';') != '' ? 'file_rec/git' : 'file_rec'`<CR>

  nnoremap <leader>ub  :Denite -mode=normal buffer file_mru<CR>

  nnoremap <leader>uY  :Denite -mode=normal neoyank<CR>
  nnoremap <leader>uf  :Denite file<CR>
  nnoremap <leader>un  :Denite file_rec:~/Projects/notes/<CR>
  nnoremap <leader>ug  :Denite -mode=normal grep:.<CR>
  nnoremap <leader>uG  :Denite -mode=normal grep:.:-i<CR>
  nnoremap <leader>ul  :Denite line<CR>
  nnoremap <leader>uT  :Denite outline<CR>
  nnoremap <leader>utc :DeniteCursorWord -buffer-name=gtags_context -immediately-1 -mode=normal gtags_context<CR>
  nnoremap <leader>utr :DeniteCursorWord -buffer-name=gtags_ref -immediately-1 -mode=normal gtags_ref<CR>
  nnoremap <leader>utd :DeniteCursorWord -buffer-name=gtags_def -immediately-1 -mode=normal gtags_def<CR>
  nnoremap <leader>utg :DeniteCursorWord -buffer-name=gtags_grep -mode=normal gtags_grep<CR>
  nnoremap <leader>utf :Denite           -buffer-name=gtags_file -mode=normal gtags_file<CR>
  nnoremap <leader>utC :Denite           -buffer-name=gtags_completion -mode=normal gtags_completion<CR>

  if executable('ag')
    " Change file_rec command.
    call denite#custom#var('file_rec', 'command',
          \ ['ag', '--follow', '--nocolor', '--nogroup', '-g', ''])

    " Ag command on grep source
    call denite#custom#var('grep', 'command', ['ag'])
    call denite#custom#var('grep', 'default_opts',
          \ ['-i', '--vimgrep'])
    call denite#custom#var('grep', 'recursive_opts', [])
    call denite#custom#var('grep', 'pattern_opt', [])
    call denite#custom#var('grep', 'separator', ['--'])
    call denite#custom#var('grep', 'final_opts', [])
  elseif executable('rg')
    " For ripgrep
    " Note: It is slower than ag
    call denite#custom#var('file_rec', 'command',
          \ ['rg', '--files', '--glob', '!.git', ''])

    " Ripgrep command on grep source
    call denite#custom#var('grep', 'command', ['rg'])
    call denite#custom#var('grep', 'default_opts',
          \ ['--vimgrep', '--no-heading'])
    call denite#custom#var('grep', 'recursive_opts', [])
    call denite#custom#var('grep', 'pattern_opt', ['--regexp'])
    call denite#custom#var('grep', 'separator', ['--'])
    call denite#custom#var('grep', 'final_opts', [])

    " For Pt(the platinum searcher)
    " NOTE: It also supports windows.
  elseif executable('pt')
    call denite#custom#var('file_rec', 'command',
          \ ['pt', '--follow', '--nocolor', '--nogroup',
          \  (has('win32') ? '-g:' : '-g='), ''])

    " Pt command on grep source
    call denite#custom#var('grep', 'command', ['pt'])
    call denite#custom#var('grep', 'default_opts',
          \ ['--nogroup', '--nocolor', '--smart-case'])
    call denite#custom#var('grep', 'recursive_opts', [])
    call denite#custom#var('grep', 'pattern_opt', [])
    call denite#custom#var('grep', 'separator', ['--'])
    call denite#custom#var('grep', 'final_opts', [])
  endif

  " Change mappings.
  call denite#custom#map(
        \ 'insert',
        \ '<C-j>',
        \ '<denite:move_to_next_line>',
        \ 'noremap'
        \)
  call denite#custom#map(
        \ 'insert',
        \ '<C-k>',
        \ '<denite:move_to_previous_line>',
        \ 'noremap'
        \)
  call denite#custom#map(
        \ 'insert',
        \ '<C-a>',
        \ '<denite:move_caret_to_head>',
        \ 'noremap'
        \)
  call denite#custom#map(
        \ 'insert',
        \ '<C-e>',
        \ '<denite:move_caret_to_tail>',
        \ 'noremap'
        \)
  call denite#custom#map(
        \ 'insert',
        \ '<A-b>',
        \ '<denite:move_caret_to_one_word_left>',
        \ 'noremap'
        \)
  call denite#custom#map(
        \ 'insert',
        \ '<A-f>',
        \ '<denite:move_caret_to_one_word_right>',
        \ 'noremap'
        \)
  call denite#custom#map(
        \ 'insert',
        \ '<A-BS>',
        \ '<denite:delete_word_before_caret>',
        \ 'noremap'
        \)
  call denite#custom#map(
        \ 'insert',
        \ '<A-d>',
        \ '<denite:delete_word_under_caret>',
        \ 'noremap'
        \)
  call denite#custom#map(
        \ 'insert',
        \ '<Up>',
        \ '<denite:move_to_previous_line>',
        \ 'noremap'
        \)
  call denite#custom#map(
        \ 'insert',
        \ '<Down>',
        \ '<denite:move_to_next_line>',
        \ 'noremap'
        \)
  call denite#custom#map(
        \ 'insert',
        \ '<S-Up>',
        \ '<denite:assign_previous_matched_text>',
        \ 'noremap'
        \)
  call denite#custom#map(
        \ 'insert',
        \ '<S-Down>',
        \ '<denite:assign_next_matched_text>',
        \ 'noremap'
        \)

  " Change matchers.
  call denite#custom#source(
        \ 'file_mru', 'matchers', ['matcher_fuzzy', 'matcher_project_files'])
  call denite#custom#source(
        \ 'file_rec', 'matchers', ['matcher_cpsm'])

  " Change sorters.
  call denite#custom#source(
        \ 'file_rec', 'sorters', ['sorter_sublime'])


  " Define alias
  call denite#custom#alias('source', 'file_rec/git', 'file_rec')
  call denite#custom#var('file_rec/git', 'command',
        \ ['git', 'ls-files', '-co', '--exclude-standard'])

  " Change default prompt
  " call denite#custom#option('default', 'prompt', '>')

  " Change ignore_globs
  call denite#custom#filter('matcher_ignore_globs', 'ignore_globs',
        \ [ '.git/', '.ropeproject/', '__pycache__/',
        \   'venv/', 'images/', '*.min.*', 'img/', 'fonts/'])
endif

command! -bang -nargs=* Ag
      \ call fzf#vim#ag(<q-args>,
      \                 <bang>0 ? fzf#vim#with_preview('up:60%')
      \                         : fzf#vim#with_preview('right:50%:hidden', '?'),
      \                 <bang>0)

function! FilesOrGfiles()
  if finddir('.git', ';') != ''
    :GFiles
  else
    :Files
  endif
endfunction

function! AgWithParam()
  call inputsave()
  let pattern = input('Enter pattern: ')
  call inputrestore()
  execute "Ag " . pattern
endfunction

" fzf version of the mappings, experimental
nnoremap <silent> <leader>fr  :call FilesOrGfiles()<CR>
nnoremap <silent> <leader>fb  :History<CR>
nnoremap <silent> <leader>fs  :GFiles?<CR>
nnoremap <silent> <leader>fn  :Files ~/Projects/notes/<CR>
nnoremap <silent> <leader>fg  :call AgWithParam()<CR>
nnoremap <silent> <leader>fl  :BLines<CR>
nnoremap <silent> <leader>fL  :Lines<CR>
nnoremap <silent> <leader>fT  :BTags<CR>

let include_paths = ['/opt/local/include','/usr/local/include','/usr/include','/Developer/Headers',fnamemodify('~/programs/include',':p')]
let g:unite_source_gtags_project_config = {
      \ '_':                   { 'gtags_libpath': include_paths }
      \ }



let g:global_objdir=$HOME . "/.cache/global-obj"
call FindOrCreate(g:global_objdir)
" For regular tags
let tag_file = g:global_objdir . "/tags"
set tags=./tags,$HOME/.cache/global-obj
function! UpdateTagDir(dir)
  if isdirectory(a:dir)
    exe 'cd ' . a:dir
    if (! filereadable(g:global_objdir . '/' . a:dir . '/GTAGS') )
      call system('gtags -O')
    else
      call system('global -u')
    endif
    cd -
  endif
endfunction
let ctags_command = 'ctags -R --c++-kinds=+p --fields=+liaS --extra=+q --tag-relative=yes --exclude=.git --exclude=.svn --exclude=.hg '
function! UpdateLocalCTags()
  call system(g:ctags_command . ' -f ./tags ' . getcwd())
endfunction
function! UpdateCTags()
  call system(g:ctags_command . ' -f ' . g:global_objdir . join(g:include_paths))
  call UpdateLocalCTags()
endfunction
set csprg=gtags-cscope
" add all databases in objdir
function! LoadCscopeDir(dir)
  echo a:dir
  let db = findfile("GTAGS", g:global_objdir . a:dir . "/;")
  if (!empty(db))
    let path = strpart(db, 0, match(db, "/GTAGS$"))
    exe 'cd ' . path
    set nocscopeverbose " suppress 'duplicate connection' error
    exe "cs add " . db . " " . path
    set cscopeverbose
    cd -
  endif
endfunction
function! LoadCscope()
  echo 'here'
  " let dbs = findfile("GTAGS", g:global_objdir . "/**", -1)
  call LoadCscopeDir(fnamemodify('.', ':p:h'))
  call LoadCscopeDir(expand('%:p:h'))
  for dir in g:include_paths
    echo dir
    " let path = substitute(db, g:global_objdir, '', '')
    " let path = strpart(path, 0, match(path, "/GTAGS$"))
    call LoadCscopeDir(dir)
  endfor
endfunction

function! UpdateGTags()
  call UpdateTagDir('.')
  for dir in g:include_paths
    call UpdateTagDir(dir)
  endfor
  call LoadCscope()
endfunction
function! UpdateAllTags()
  call UpdateGTags()
  call UpdateCTags()
endfunction
function! UpdateLocalTags()
  call UpdateTagDir('.')
  call UpdateLocalCTags()
endfunction
augroup UniteTagsRemap
  autocmd BufEnter *
        \   if empty(&buftype)
        \|      nnoremap <buffer> <C-]> :<C-u>UniteWithCursorWord -immediately tag<CR>
        \|  endif
augroup END

if 0
  " For global tags
  if has("cscope")
    set csto=0
    set cst
    set nocsverb


    " add any database in or above the current directory
    " function! LoadCscope()
    "     let db = findfile("GTAGS", $HOME . "/.dotfiles/global-obj" . getcwd() . ";")
    "     if (!empty(db))
    "         let path = strpart(db, 0, match(db, "/GTAGS$"))
    "         set nocscopeverbose " suppress 'duplicate connection' error
    "         exe "cs add " . db . " " . getcwd()
    "         set cscopeverbose
    "     endif
    " endfunction
    " augroup cscopeloader
    "     au!
    "     au BufEnter /* call LoadCscope()
    " augroup END
    call LoadCscope()
    set csverb
  endif
endif
" augroup unite_gtags_binding
"     au!
"     autocmd BufEnter *
"                 \   if empty(&buftype)
"                 \|      nnoremap <buffer> <C-]> :<C-u>Unite -immediately gtags/context<CR>
"                 \|  endif
" augroup END
" nnoremap <leader>ur :<C-u>Unite -start-insert file_rec<CR>

if executable('rg')
  let unite_ignores = ["!CMakeFiles",
        \"!*.dSYM",
        \"!*.dat",
        \"!*.pdf",
        \"!*.bib"]
  let unite_globs = []
  for ig in unite_ignores
    call add(unite_globs, "--glob '" . ig . "'")
  endfor
  " Use rg in unite grep source.
  let g:unite_source_grep_command = 'rg'
  let g:unite_source_grep_default_opts = ' --smart-case -n --no-heading --color never --no-messages ' .
        \ join(unite_globs) . ' -e '
  let g:unite_source_grep_separator = "" "avoid having unite add '--' where it doesn't go
  let g:unite_source_grep_recursive_opt = ''
  " The empty perens set the pattern, all files should match
  let unite_globs2 = []
  for ig in unite_ignores
    call add(unite_globs2, '--glob')
    call add(unite_globs2, ig)
  endfor
  let g:unite_source_rec_async_command = ['rg', '--color', 'never', '--no-heading', '--files'] + unite_globs2
elseif executable('pt')
  " Use pt in unite grep source.
  " https://github.com/monochromegane/the_platinum_searcher
  let g:unite_source_grep_command = 'pt'
  let g:unite_source_grep_default_opts = ' --smart-case --nogroup --nocolor ' .
        \ '--ignore ''*.dat'' --ignore ''*.pdf'' --ignore ''*.bib'' -e '
  let g:unite_source_grep_recursive_opt = ''
  " The empty perens set the pattern, all files should match
  let g:unite_source_rec_async_command = ['pt', '--nocolor', '--nogroup', '-g', ".", ""]
elseif executable('ag')
  " Use ag in unite grep source.
  let g:unite_source_grep_command = 'ag'
  let g:unite_source_grep_default_opts =
        \ '--line-numbers --nocolor --nogroup --hidden ' .
        \ '--ignore ''CMakeFiles'' ' .
        \ '--ignore ''*.dat'' --ignore ''*.pdf'' --ignore ''build*''  '
  let g:unite_source_grep_recursive_opt = ''
  let g:unite_source_rec_async_command = ['ag', '-i', '--nocolor', '--nogroup', '--ignore', 'build*', '--ignore', '.git', '--ignore', '.bzr', '--ignore', 'node_modules', '--hidden', '-g', ""]
else
  let g:unite_source_rec_find_args = ['-path', '*/.git/*', '-prune', '-o', '-path', '*/build*/*', '-prune', '-o', '-print']
endif

"YouCompleteMe
nnoremap <leader>jd :YcmCompleter GoToDefinitionElseDeclaration<CR>
"attempt to fix the awful latex input behavior
" set omnifunc=syntaxcomplete#Complete
" let g:ycm_semantic_triggers = {
"       \  'tex'  : ['{'],
"       \ }
" let g:ycm_filetype_blacklist = {
"       \ 'tex' : 1
"       \}
let g:ycm_complete_in_strings = 1
let g:ycm_extra_conf_vim_data=['&filetype']
let g:ycm_global_ycm_extra_conf = '~/.ycm_extra_conf.py'
let g:ycm_extra_conf_globlist = ['~/Dropbox/*','~/projects/*','~/Projects/*']
let g:ycm_autoclose_preview_window_after_insertion = 1
let g:ycm_key_invoke_completion = '<C-S-Space>'
let g:ycm_key_list_select_completion = ['<C-n>', '<Down>', '<Tab>']
let g:ycm_key_list_previous_completion = ['<C-p>', '<Up>', '<S-Tab>']

let g:UltiSnipsExpandTrigger="<c-j>"
inoremap <S-tab> <Esc>:call UltiSnips_ListSnippets()<CR>

"syntax/visual options
let g:vimsyn_folding = 'aflP'
let g:vimsyn_embed = 'lP'
let g:sh_fold_enabled= 7 "    (enable all folding)
set vb
set t_vb=
syn on
set ruler
set nowrap

set winaltkeys=no
set virtualedit=block,insert

set suffixes+=*.com,*.class,*.dll,*.exe,*.o,*.so
set suffixes+=*.dmg,*.iso,*.jar,*.rar,*.tar,*.zip
set suffixes+=".DS_Store,.DS_Store?,._*,.Spotlight-V100,ehthumbs.db,Thumbs.db"
set suffixes+=*.swp,*~
set suffixes+=*.aux,*.lot,*.lof,*.pyg,*.toc
set suffixes+=*.pdf,*.eps,*.epsi,*.png,*.jpg,*.svg
" set suffixes+=*.xls,*.xlsx,*.ppt,*.pptx,*.doc,*.docx,*.graffle

"outliner checkboxes
augroup filetype_otl
  autocmd!
  au FileType otl source ~/.vim/plugin/vo_checkbox.vim
  au FileType otl setlocal spell spelllang=en_us
augroup END

"additional buffer types
augroup extra_filetypes
  autocmd!
  au BufNewFile,BufRead *.cu           set      ft=cuda
  au BufNewFile,BufRead *.cuh          set      ft=cuda
  au BufNewFile,BufRead *.cl           set      ft=opencl
  au BufNewFile,BufRead *.br           set      ft=brook
  au BufNewFile,BufRead *.go           set      ft=go
  au FileType           go             setlocal formatprg=gofmt
  au BufRead            COMMIT_EDITMSG set      backupcopy=no
  au BufNewFile,BufRead *.txt          set      ft=txt
  au BufNewFile,BufRead CMakeLists.txt set      ft=cmake
  au BufNewFile,BufRead CMakeCache.txt set      ft=cmake
augroup END

"for plugins, etc.
set encoding=utf-8



"remove ending whitespace on file write
fun! <SID>StripTrailingWhitespaces()
  let save_cursor = getpos(".")
  let old_query = getreg('/')
  :%s/\s\+$//e
  call setpos('.', save_cursor)
  call setreg('/', old_query)
endfun
" Save a file as root (,W)
noremap <leader>W :w !sudo tee % > /dev/null<CR>

" augroup extra_filetypes
" autocmd!
" autocmd BufWritePre <buffer> :call <SID>StripTrailingWhitespaces()
" augroup END

" Disable spell checking in comments
let g:tex_comment_nospell= 1
fun! TeX_fmt()
  if (getline(".") != "")
    let save_cursor = getpos(".")
    let op_wrapscan = &wrapscan
    set nowrapscan
    let par_begin = '^\(%D\)\=\s*\($\|\\begin\|\\end\|\\Start\|\\Stop\|\\\(sub\)*section\>\|\\item\>\|\\NC\>\|\\blank\>\|\\noindent\>\)'
    let par_end   = '^\(%D\)\=\s*\($\|\\begin\|\\end\|\\Start\|\\Stop\|\\place\|\\\(sub\)*section\>\|\\item\>\|\\NC\>\|\\blank\>\)'
    try
      exe '?'.par_begin.'?+'
    catch /E384/
      1
    endtry
    norm V
    try
      exe '/'.par_end.'/-'
    catch /E385/
      $
    endtry
    norm gq
    let &wrapscan = op_wrapscan
    call setpos('.', save_cursor)
  endif
endfun

"CODE LINTING
let g:syntastic_tex_checkers=[] "do NOT check latex files
" let g:syntastic_cpp_checkers=['cpplint']
let g:syntastic_python_checkers=['pylint', 'pep8', 'python']
let g:syntastic_python_pylint_args=' --indent-string="    "'
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 0
let g:syntastic_check_on_wq = 0
let g:syntastic_mode_map = {
      \ "mode": "passive",
      \ "active_filetypes": [],
      \ "passive_filetypes": [] }

" if executable("astyle")
"     "astyle args for C and C++
"     let g:formatdef_my_custom_astyle = '"--indent-col1-comments --style=stroustrup -A4 --align-pointer=name --max-code-length=80 --convert-tabs"'
"     let g:formatters_c = ['my_custom_astyle'] + g:formatters_c
"     let g:formatters_cpp = ['my_custom_astyle'] + g:formatters_cpp
"     " let g:formatprg_args_expr_c = '"--mode=c --style=google --add-brackets --indent-preproc-define --keep-one-line-statements -pcH".(&expandtab ? "s".&shiftwidth : "t")'
" endif

"automatic formatting options
set textwidth=80
augroup git_messages
  autocmd!
  au FileType gitcommit setlocal textwidth=72
augroup END
set formatoptions=crq
" set fo-=t
" au FileType tex set formatoptions+=a
augroup text_formatting
  autocmd!
  au FileType tex setlocal formatoptions+=t
  au FileType tex setlocal formatexpr=cindent
  au FileType txt setlocal formatoptions+=t
  au FileType txt setlocal formatexpr=cindent
augroup END
"set formatoptions+=a

"hilighting
let python_highlight_all = 1
"there is no local value for fp, must set other languages to use cindent
"manually

map      <C-k>     :Autoformat<CR>
noremap  <C-k>     :Autoformat<CR>
nnoremap <C-k>     :Autoformat<CR>
vmap     <C-k>     <Esc>:Autoformat<CR>
imap     <C-k>     <Esc>:Autoformat<CR>
omap     <C-k>     <Esc>:Autoformat<CR>



"Conque
nmap <C-w><S-v> :ConqueTermVSplit zsh<CR>
nmap <C-w><S-s> :ConqueTermSplit zsh<CR>
let g:ConqqueTerm_Color = 2
let g:ConqueTerm_ReadUnfocused = 1
let g:ConqueTerm_CWInsert = 1

let g:tmuxline_preset = 'full'
let g:tmuxline_powerline_separators = 0
" use ascii symbols instead of unicode, expariment
" let g:airline_symbols_ascii = 1
let g:airline#extensions#tmuxline#enabled = 1
let g:airline#extensions#bufferline#enabled = 1
let g:airline#extensions#branch#enabled = 1
let g:airline#extensions#tagbar#enabled = 1
let g:airline#extensions#tagbar#flags = 'f'
let g:airline#extensions#quickfix#enabled = 1
let g:airline#extensions#branch#displayed_head_limit = 10
let g:airline#extensions#csv#enabled = 1
set timeoutlen=300
set ttimeoutlen=10

map <C-F12> :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q $PWD<CR>
map <A-C-T> :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q $PWD<CR>
map <Esc><C-T> :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q $PWD<CR>
" execute 'map <C-S-F12> :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q -f - ' . include_paths . ' > ~/.vim-systags'

if has("gui_running")
  set guioptions=egmt
  if has("gui_macvim")
    "CRITICAL option, allows alt-based key-bindings to work in macvim
    set macmeta
    set transparency=10
    " set gfn=Courier\ New:h11.00
    set gfn=ProFontX:h9.00
    set noantialias
    set fuopt=maxvert,maxhorz
  elseif has("gui_gtk2")
    set guifont=Terminus\ 8
  elseif has("x11")
    " Also for GTK 1
    set guifont=-misc-fixed-medium-r-normal-*-10-*-*-*-c-*-iso8859-15
  endif
endif

if exists("neovim_dot_app") || has("gui_vimr") " VimR thinks it isn't a gui..?
  let g:terminal_color_0 = '#2e3436'
  let g:terminal_color_1 = '#cc0000'
  let g:terminal_color_2 = '#4e9a06'
  let g:terminal_color_3 = '#c4a000'
  let g:terminal_color_4 = '#3465a4'
  let g:terminal_color_5 = '#75507b'
  let g:terminal_color_6 = '#0b939b'
  let g:terminal_color_7 = '#d3d7cf'
  let g:terminal_color_8 = '#555753'
  let g:terminal_color_9 = '#ef2929'
  let g:terminal_color_10 = '#8ae234'
  let g:terminal_color_11 = '#fce94f'
  let g:terminal_color_12 = '#729fcf'
  let g:terminal_color_13 = '#ad7fa8'
  let g:terminal_color_14 = '#00f5e9'
  let g:terminal_color_15 = '#eeeeec'
endif


function! Map_for_all(mapping, target, ...)
  let l:for_input = (a:0 >= 1) ? a:1 : 0
  let l:for_cmd = (a:0 >= 2) ? a:2 : 0
  let l:for_terminal = (a:0 >= 3) ? a:3 : 0

  for item in ['nnoremap', 'vmap', 'omap']
    execute item . ' ' . a:mapping . ' ' . a:target
  endfor

  if has("nvim")
    if l:for_terminal != 0
      execute 'tnoremap '.a:mapping.' <C-\><C-n>'.a:target
    endif
  endif

  if l:for_cmd != 0
    execute 'cmap '.a:mapping.' '.a:target
  endif

  if l:for_input > 1
    execute 'imap ' . a:mapping . ' <esc>' . a:target
  else
    execute 'imap ' . a:mapping . ' ' . a:target
  endif
endfunction

function! Map_for_all_meta(mapping, target, ...)
  let l:for_input = (a:0 >= 1) ? a:1 : 2
  let l:for_cmd = (a:0 >= 2) ? a:2 : 1
  let l:for_terminal = (a:0 >= 3) ? a:3 : 1

  call Map_for_all('<A-'.a:mapping.'>', a:target, l:for_input, l:for_cmd, l:for_terminal)
  let l:mapping = split(a:mapping, '-')
  if len(l:mapping) == 2 && l:mapping[0] == "S"
    let l:mapping = toupper(l:mapping[1])
  else
    let l:mapping = a:mapping
  endif
  call Map_for_all('<Esc>'.l:mapping, a:target, l:for_input, l:for_cmd, l:for_terminal)
endfunction


"Normalize backspace
set t_kb=
call Map_for_all("", "<BS>", 1, 1)

if &term =~ "screen.*" "screen configurations
  if &term =~ "screen.*-bce"
    set term=screen-256color
  endif
  "set ttymouse=xterm "falls back to xterm for unsupported terminal type
  set t_ku=OA
  set t_kd=OB
  set t_kr=OC
  set t_kl=OD
  set t_@7=OF
  set t_kh=[1~

  call Map_for_all("<Esc>[C", "<Right>", 1, 1)
  call Map_for_all("<Esc>[D", "<Left>", 1, 1)
  call Map_for_all("<Esc>[A", "<Up>", 1, 1)
  call Map_for_all("<Esc>[B", "<Down>", 1, 1)

  call Map_for_all("<Esc>[4~", "<End>", 1, 1)
  call Map_for_all("<Esc>[1~", "<Home>", 1, 1)

  call Map_for_all("<Esc>0F", "<End>", 1, 1)
  call Map_for_all("<Esc>OH", "<Home>", 1, 1)
  call Map_for_all("<Esc>[F", "<End>", 1, 1)
  call Map_for_all("<Esc>[H", "<Home>", 1, 1)
endif


" tComment extra mappings:
" yank visual before toggle comment
vmap gy ygvgc
" yank and past visual before toggle comment
vmap gyy ygvgc'>gp'.
" yank line before toggle comment
nmap gy yygcc
" yank and paste line before toggle comment and remember position
" it works both in normal and insert mode
" Use :t-1 instead of yyP to preserve registers
nmap gyy mz:t-1<cr>gcc`zmz
" imap gyy <esc>:t-1<cr>gCcgi
vmap gcc gc

" nnoremap <Leader>x :call NERDComment(0,"toggle")<C-m>
" vmap <Leader>x :call NERDComment(0,"toggle")<C-m>
" let g:NERDRemoveExtraSpaces=1
" let g:NERDRemoveExtraSpaces=1
" let g:NERDSpaceDelims=1

"map <Leader>x <plug>NERDCommenterToggleComment
" Follow links with ,o
nnoremap <Leader>o :Utl ol<CR>
let g:utl_cfg_hdl_scm_http_system = 'silent !open "%u"'
let g:utl_cfg_hdl_scm_http = 'silent !open "%u"'
let g:utl_cfg_hdl_mt_generic = 'silent !open "%p"'

imap <A-x> <Esc><Plug>Traditionala
imap <Esc>x <Esc><Plug>Traditionala

"csupport, but very commentify related...
let g:C_TypeOfH="c"

"editing behavior
set history=10000
set backspace=2
" set softtabstop=2 "used to favor the gnu style, getting used to K&R @ 4 spaces
" set shiftwidth=2
set softtabstop=2
set shiftwidth=2
set expandtab
set hlsearch
set incsearch
set ignorecase
set smartcase
set modeline
set modelines=5
" Optimize for fast terminal connections
set ttyfast
" Use UTF-8 without BOM
set encoding=utf-8 nobomb
" Centralize backups, swapfiles and undo history, make dropbox happy!
call FindOrCreate("~/.vim-backups")
set backupdir=~/.vim-backups
call FindOrCreate("~/.vim-swaps")
set directory=~/.vim-swaps//
if exists("&undodir")
  call FindOrCreate("~/.vim-undo")
  set undodir=~/.vim-undo
endif
" Enable per-directory .vimrc files and disable unsafe commands in them
set exrc
set secure
" Highlight current line
" set cursorline
" set cursorcolumn
augroup cursorhighlight
  au!
  autocmd BufEnter *
        \   if (&buftype == 'nofile')
        \|      set nocursorline
        \|      set nocursorcolumn
        \|  endif
augroup END
" Show ‚Äúinvisible‚Äù characters
" set lcs=tab:‚ñ∏\ ,trail:¬∑,eol:¬¨,nbsp:_
set lcs=tab:‚ñ∏\ ,trail:¬∑,nbsp:_
highlight WhitespaceEOL ctermbg=red guibg=red
match WhitespaceEOL /\s\+$/
set list
" Always show status line
set laststatus=2
" Don‚Äôt reset cursor to start of line when moving around.
set nostartofline
" Show the cursor position
set ruler
" Don‚Äôt show the intro message when starting Vim
set shortmess=atI
" Show the current mode
set showmode
" Show the (partial) command as it‚Äôs being typed
" nice, but slow
" set showcmd
" Start scrolling three lines before the vertical window border
set scrolloff=3
" Start scrolling three lines before the horizontal window border
set sidescrolloff=3

" Append modeline after last line in buffer.
" Use substitute() instead of printf() to handle '%%s' modeline in LaTeX
" files.
function! AppendModeline()
  let l:modeline = printf(" vim: set ts=%d sw=%d tw=%d %set :",
        \ &tabstop, &shiftwidth, &textwidth, &expandtab ? '' : 'no')
  let l:modeline = substitute(&commentstring, "%s", l:modeline, "")
  call append(line("$"), l:modeline)
endfunction
nnoremap <silent> <Leader>ml :call AppendModeline()<CR>


"diff behavior
set diffopt+=iwhite

"indent
set autoindent
set smartindent

"c/c++ options
augroup c_setup
  autocmd!
  au FileType c set foldmethod=syntax
augroup END

"latex options
let g:LatexBox_viewer = 'open -a Skim'
let g:LatexBox_quickfix = 0
let g:LatexBox_latexmk_options = '-pdf -shell-escape' "latter is needed for pygments
let g:LatexBox_latexmk_preview_continuously=0
let g:tex_flavor='latex'
let g:Imap_FreezeImap=1
let g:Tex_FormatDependency_pdf = 'pdf'
if has('macunix')
  let g:Tex_ViewRule_pdf = 'open '
  let g:Tex_ViewRuleComplete_pdf = 'open $*.pdf'
elseif has('unix')
  let g:Tex_ViewRule_pdf = 'evince '
  let g:Tex_ViewRuleComplete_pdf = 'evince $*.pdf'
endif
map <silent> <Leader>ls :silent
      \ !/Applications/Skim.app/Contents/SharedSupport/displayline
      \ <C-R>=line('.')<CR> "<C-R>=LatexBox_GetOutputFile()<CR>"
      \ "%:p" <CR>
nmap <silent> <Leader>wc bi\code{<esc>ea}<esc>
vmap <silent> <Leader>wc di\code{}<esc>P

let g:Tex_DefaultTargetFormat = 'pdf'

let g:Tex_CompileRule_pdf = 'pdflatex -synctex=1 --interaction=nonstopmode $*'

let g:Tex_ViewRule_pdf = 'Skim'

" let g:Tex_IgnoredWarnings ='
"       \"Underfull\n".
"       \"Overfull\n".
"       \"specifier changed to\n".
"       \"You have requested\n".
"       \"Missing number, treated as zero.\n".
"       \"There were undefined references\n".
"       \"Citation %.%# undefined\n".
"       \"\oval, \circle, or \line size unavailable\n"'

nmap wip diwi\plc{}<Esc>P
nmap wic diwi\code{}<Esc>P

function! Find_main_latex()
  let latexmain = findfile("paper.tex", ".;")
  if (!empty(latexmain))
    return latexmain
  endif
  let latexmain = findfile("header.tex", ".;")
  if (!empty(latexmain))
    return latexmain
  endif
  let basedir = finddir(".git", ".;")
  if (isdirectory(basedir))
    let latexmain = glob(basedir . "/*.latexmain")
    if (filereadable(latexmain))
      return substitute(latexmain, ".latexmain", "", "")
    endif
  endif
  return ""
endfunction

augroup text_setup
  autocmd!
  au FileType tex let g:Tex_DefaultTargetFormat='pdf'
  au FileType tex setlocal spell spelllang=en_us
  " au FileType tex imap <C-x><C-p> <Plug>Tex_Completion
  au FileType tex imap <buffer> <C-b> <Plug>Tex_MathBF
  au FileType tex imap <buffer> <C-l> <Plug>Tex_LeftRight
  " conflict with ctrl-p
  " au FileType tex imap <buffer> <C-p> <Plug>Tex_InsertItemOnThisLine
  au FileType tex imap <buffer> <A-i> <Plug>Tex_InsertItemOnThisLine
  au FileType tex imap <buffer> <Esc>i <Plug>Tex_InsertItemOnThisLine
  au FileType tex let b:main_tex_file=Find_main_latex()

  " Highlight words I might use to mess up grammar
  au FileType tex highlight whichthat ctermfg=Magenta guifg=#515996
  "ctermfg=black
  au FileType tex match whichthat /\(\swhich\s\|\sthat\s\)/

  au FileType txt set textwidth=80
  au FileType txt setlocal spell spelllang=en_us
  au FileType help setlocal nospell spelllang=en_us
augroup END

"build system options
" Command Make will call make and then cwindow which
" opens a 3 line error window if any errors are found.
" if no errors, it closes any open cwindow.
command! -nargs=* Make make <args> | cwindow 3
command! -nargs=* Scons scons <args> | cwindow 3
nnoremap <Leader>m :Make<cr>

augroup build_autos
  autocmd!
  au BufRead,BufNewFile SConstruct set filetype=python

  au FileType make inoremap <buffer> <tab> <tab>
  au FileType make setlocal softtabstop=0
  au FileType make setlocal shiftwidth=8
  au FileType make setlocal noexpandtab
  au FileType make setlocal noautoindent
  au FileType make setlocal nosmartindent
augroup END

function! Clang_rename_string(new_name)
  "Save window state
  let winview=winsaveview()

  "Rename symbol
  exe "1,$!clang-rename -offset " . (line2byte( line('.'))+col('.')) . " -new-name='" . a:new_name . "' %"
  "clang-rename -offset 4156 -new-name=do_other_stuff_for_some_reason -pl -pn

  "Recall window state
  call winrestview(winview)
endfunction

function! Clang_rename()
  call inputsave()
  let name = input('Enter name: ')
  call inputrestore()
  call Clang_rename_string(name)
endfunction



"general key remappings
nmap Y y$

" call Map_for_all("<C-c>","<Esc>", 1, 1)

map <S-Z><S-S> :up<CR>


if ! InGui()
  "new experiment, using xterm clipboard escapes for copy portability, no paste
  "(I think..?)

  vmap <silent> <A-c>        :Oscyank<CR>
  vmap <silent> <Esc>c       :Oscyank<CR>
  nmap <silent> <A-c>        :Oscyank<CR>
  nmap <silent> <Esc>c       :Oscyank<CR>

  "if $TMUX "TODO: get copy support for tmux, need to figure out what mappings
  "make sense...
  "vmap <silent> <A-C>        "py:call eval('system("tmux set-buffer \'" . @p . "\'")')<CR>
  "vmap <silent> <Esc>C       "py:call eval('system("tmux set-buffer \'" . @p . "\'")')<CR>
  "vmap <silent> <A-V>        dh:call Paste_proper()<CR>
  "vmap <silent> <Esc>V       dh:call Paste_proper()<CR>
  "imap <silent> <A-V>        <Esc>: call Paste_proper()<CR>
  "imap <silent> <Esc>V       <Esc>: call Paste_proper()<CR>
  "nmap <silent> <A-C>        :yank p<CR>:call Yank_proper()<CR>
  "nmap <silent> <Esc>C       :yank p<CR>:call Yank_proper()<CR>
  "nmap <silent> <A-V>        :call Paste_proper()<CR>
  "nmap <silent> <Esc>V       :call Paste_proper()<CR>
  "endif
  "nnoremap <special> <A-c> "*Y
  " cnoremap <special> <A-c> <C-R>+
  "vnoremap <special> <A-c> "*y
  if has('macunix')
    let tmux_reattach_prefix="reattach-to-user-namespace"
    if (! executable(tmux_reattach_prefix))
      let tmux_reattach_prefix=glob("~/Dropbox/config/tmux-MacOSX-pasteboard/reattach-to-user-namespace")
    elseif (! filereadable(tmux_reattach_prefix))
      let tmux_reattach_prefix=glob("~/Projects/config-sync/tmux-MacOSX-pasteboard/reattach-to-user-namespace")
    endif

    "paste from pbpaste as paste normally works, from the current cursor position
    function! Paste_proper()
      let @p=system(g:tmux_reattach_prefix . " pbpaste")
      execute 'normal "pp'
    endfunction
    vmap <silent> <A-v>        dh:call Paste_proper()<CR>
    vmap <silent> <Esc>v       dh:call Paste_proper()<CR>
    imap <silent> <A-v>        <Esc>: call Paste_proper()<CR>
    imap <silent> <Esc>v       <Esc>: call Paste_proper()<CR>
    nmap <silent> <A-v>        :call Paste_proper()<CR>
    nmap <silent> <Esc>v       :call Paste_proper()<CR>
  endif

  function! Old_yank_support()
    if $ITERM_PROFILE
      vmap <C-y> y:call system("xclip", getreg("\""))<CR>
      "attempt to yank through iterm2 termcode
      function! Yank_proper()
        "each mode needs different copy, see below mappings
        " echo system("cat << StringNotLikelyToBeCopied\n" . getreg("p") . "\nStringNotLikelyToBeCopied")
        if has("python")
          python import vim, sys, subprocess
          python p=subprocess.Popen(["cat"], stdin=subprocess.PIPE)
          python p.stdin.write('\033]50;CopyToClipboard=')
          python p.stdin.write(vim.eval('getreg("p")'))
          python p.stdin.write('\033]50;EndCopy')
          python p.stdin.close()
        elseif has("python3")
          python3 import vim, sys, subprocess
          python3 p=subprocess.Popen(["cat"], stdin=subprocess.PIPE)
          python3 p.stdin.write('\033]50;CopyToClipboard=')
          python3 p.stdin.write(vim.eval('getreg("p")'))
          python3 p.stdin.write('\033]50;EndCopy')
          python3 p.stdin.close()
        endif
        redraw!
      endfunction
      vmap <silent> <A-c>        "py:call Yank_proper()<CR>
      vmap <silent> <Esc>c       "py:call Yank_proper()<CR>
      nmap <silent> <A-c>        :yank p<CR>:call Yank_proper()<CR>
      nmap <silent> <Esc>c       :yank p<CR>:call Yank_proper()<CR>
    elseif has('macunix')
      function! Yank_proper()
        "each mode needs different copy, see below mappings
        call system(g:tmux_reattach_prefix . " pbcopy", getreg("p"))
      endfunction

      vmap <silent> <A-c>        "py:call Yank_proper()<CR>
      vmap <silent> <Esc>c       "py:call Yank_proper()<CR>
      nmap <silent> <A-c>        :yank p<CR>:call Yank_proper()<CR>
      nmap <silent> <Esc>c       :yank p<CR>:call Yank_proper()<CR>
    endif
  endfunction
  " execute 'inoremap <script> <special> <A-c>' paste#paste_cmd['i']
  " nnoremap <special> <Esc>c "+gP
  " cnoremap <special> <Esc>c <C-R>+
  " execute 'cnoremap <script> <special> <Esc>c' paste#paste_cmd['c']
  " execute 'inoremap <script> <special> <Esc>c' paste#paste_cmd['i']
  "nnoremap <special> <A-v> "+gP
  "cnoremap <special> <A-v> <C-R>+
  "execute 'vnoremap <script> <special> <A-v>' paste#paste_cmd['v']
  "execute 'inoremap <script> <special> <A-v>' paste#paste_cmd['i']
  "nnoremap <special> <Esc>v "+gP
  "cnoremap <special> <Esc>v <C-R>+
  "execute 'vnoremap <script> <special> <Esc>v' paste#paste_cmd['v']
  "execute 'inoremap <script> <special> <Esc>v' paste#paste_cmd['i']
  call Map_for_all("<Esc>[1;3C", "<End>", 1, 1)
  call Map_for_all("<Esc>[1;3D", "<Home>", 1, 1)
  call Map_for_all("<Esc>[1;9D", "<C-Left>", 1, 1)
  call Map_for_all("<Esc>[1;9C", "<C-Right>", 1, 1)

endif


""tag jump remappings, makes <C-]> list if more than 1, immediate if only 1,
""alt does the same, but in a new vertical split so you can look at both
""together, awesome for looking at function arguments and defs together
" function! Vertical_tag_jump()
"     execute "vert rightb stj " . expand("<cword>")
" endfunction
" map  <C-]>   g<C-]>
" imap  <C-]>  <Esc>g<C-]>
" cmap  <C-]>  g<C-]>

if exists("neovim_dot_app")
  call MacSetOptionAsMeta(1)
endif
" if ! has("gui_running")
"alt
"tab management
call Map_for_all_meta('t', ":tabnew<CR>", 2, 1, 1)
call Map_for_all_meta('}', ":tabnext<CR>", 2, 1, 1)
call Map_for_all_meta('{', ":tabprevious<CR>", 2, 1, 1)
call Map_for_all_meta('w', ":tabclose<CR>", 2, 1, 1)

"Powerline
set laststatus=2 "keeps the statusbar on
let g:Powerline_symbols = 'unicode'
if exists("$HOST")
  if $HOST == "typhoon"
    let g:Powerline_symbols = 'fancy'
  endif
endif
"let g:Powerline_theme = 'default'
let g:Powerline_colorscheme = 'solarized256'
"if
"let g:Powerline_symbols = 'fancy'
"let g:Powerline_symbols = 'unicode'
"let g:Powerline_theme = 'default'
"let g:Powerline_colorscheme = 'solarized256'

"general options
set grepprg=grep\ -nH\ $*
" Enhance command-line completion
set wildmenu
set wildmode=longest:list,full
set foldmethod=syntax
" set foldcolumn=1 " show fold depth in the gutter
filetype indent on
filetype plugin on

"winmanager
let g:winManagerWindowLayout = "Project|TagList"

"window switching
call Map_for_all_meta("S-h", "<C-w>h", 2, 0, 1)
call Map_for_all_meta("S-j", "<C-w>j", 2, 0, 1)
call Map_for_all_meta("S-k", "<C-w>k", 2, 0, 1)
call Map_for_all_meta("S-l", "<C-w>l", 2, 0, 1)

if has("nvim")
  tnoremap <C-w> <C-\><C-n><C-w>
endif

let g:vimfiler_as_default_explorer = 1
function! ToggleVExplorer()
  if g:vimfiler_as_default_explorer
    VimFilerExplorer
  else
    if exists("t:expl_buf_num")
      let expl_win_num = bufwinnr(t:expl_buf_num)
      if expl_win_num != -1
        let cur_win_nr = winnr()
        exec expl_win_num . 'wincmd w'
        close
        exec cur_win_nr . 'wincmd w'
        unlet t:expl_buf_num
      else
        unlet t:expl_buf_num
      endif
    else
      exec '1wincmd w'
      Vexplore
      exec 'wincmd H'
      let t:expl_buf_num = bufnr("%")
    endif
  endif
endfunction

nnoremap <silent> <M-f>      :call ToggleVExplorer()<CR>
nnoremap <silent> <A-S-f>    :call ToggleVExplorer()<CR>
nnoremap <silent> <Esc><S-f> :call ToggleVExplorer()<CR>
nnoremap <silent> <D-F>      :call ToggleVExplorer()<CR>
nmap     <silent> <F3>       :call ToggleVExplorer()<CR>
let g:netrw_liststyle = 4
" let g:netrw_home      = '~/.vim'

nnoremap <silent> <C-L> :noh<CR><C-L>
"project plugin options
" map           <A-S-o> :Project<CR>:redraw<CR>
" map           <Esc><S-o> :Project<CR>:redraw<CR>
" map           <D-O> :Project<CR>:redraw<CR>
" replaced with netrw for now
" nnoremap   <silent>   <A-S-f> :NERDTreeToggle<CR>
" nnoremap   <silent>   <Esc><S-f> :NERDTreeToggle<CR>
" nnoremap   <silent>   <D-F> :NERDTreeToggle<CR>
" map  <silent>         <A-S-p> <Plug>ToggleProject
" map  <silent>         <Esc><S-p> <Plug>ToggleProject
" map  <silent>         <D-P> <Plug>ToggleProject
" nmap <silent> <F3>    <Plug>ToggleProject
let g:proj_run1 = "!open %f"
let g:proj_window_width = 30
let g:proj_window_increment = 50
let g:proj_run_fold1 = ":!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q -f - %f > %d/tags"


" --------------------
" TagList
" --------------------
" F4:  Switch on/off TagList
nnoremap <silent> <F4> :TagbarToggle<CR>
nnoremap <silent> <A-S-t> :TagbarToggle<CR>
nnoremap <silent> <Esc><S-t> :TagbarToggle<CR>
nnoremap <silent> <D-T> :TagbarToggle<CR>

let g:tagbar_autoclose = 1

"mouse options
set mouse=a
"enable wide mouse support for iTerm2 and urxvt, should also work in new xterms
if !has("nvim")
  if has('mouse_sgr')
    set t_RV=
    set ttymouse=sgr
  else
    set ttymouse=xterm2
  endif
endif



" TagListTagName  - Used for tag names
highlight MyTagListTagName gui=bold guifg=Black guibg=Green cterm=bold ctermfg=Black ctermbg=Green
" TagListTagScope - Used for tag scope
highlight MyTagListTagScope gui=NONE guifg=Blue ctermfg=Blue
" TagListTitle    - Used for tag titles
highlight MyTagListTitle gui=bold guifg=DarkRed guibg=LightGray cterm=bold ctermfg=DarkRed ctermbg=LightGray
" TagListComment  - Used for comments
highlight MyTagListComment guifg=DarkGreen ctermfg=DarkGreen
" TagListFileName - Used for filenames
highlight MyTagListFileName gui=bold guifg=Black guibg=LightBlue cterm=bold ctermfg=Black ctermbg=LightBlue

"let Tlist_Ctags_Cmd = $VIM.'/vimfiles/ctags.exe' " location of ctags tool
" let Tlist_Show_One_File = 1 " Displaying tags for only one file~
let Tlist_Exist_OnlyWindow = 1 " if you are the last, kill yourself
let Tlist_Use_Right_Window = 1 " split to the right side of the screen
let Tlist_Sort_Type = "order" " sort by order or name
let Tlist_Display_Prototype = 0 " do not show prototypes and not tags in the taglist window.
let Tlist_Compart_Format = 1 " Remove extra information and blank lines from the taglist window.
let Tlist_GainFocus_On_ToggleOpen = 1 " Jump to taglist window on open.
let Tlist_Display_Tag_Scope = 1 " Show tag scope next to the tag name.
let Tlist_Close_On_Select = 1 " Close the taglist window when a file or tag is selected.
let Tlist_Enable_Fold_Column = 0 " Don't Show the fold indicator column in the taglist window.
let Tlist_WinWidth = 30
"let Tlist_Ctags_Cmd = 'ctags --c++-kinds=+p --fields=+iaS --extra=+q --languages=c++'
" very slow, so I disable this
"let Tlist_Process_File_Always = 1 " To use the :TlistShowTag and the :TlistShowPrototype commands without the taglist window and the taglist menu, you should set this variable to 1.
":TlistShowPrototype [filename] [linenumber]
"
let g:lisp_rainbow=1

" Highlight words I might use to mess up grammar
au FileType tex highlight whichthat ctermfg=Magenta guifg=#515996
"ctermfg=black
au FileType tex match whichthat /\(\swhich\s\|\sthat\s\)/


" colorscheme solarized
if &term =~ ".*256color.*" || has("gui_running")
  if $COLORTERM == "truecolor"
    set termguicolors
  else
  set t_Co=256
  endif
  " let g:inkpot_black_background=1
  " colorscheme inkpot
endif

" let g:jellybeans_overrides = {
"             \    'background': { 'ctermbg': 'Black' },
"             \}
if !has("gui_running")
  " let g:jellybeans_background_color = "000000"
  " let g:jellybeans_use_lowcolor_black = 1
  " let g:jellybeans_background_color_256="0"
endif

" set background=dark
" let g:solarized_contrast = "high"
let g:solarized_contrast = "normal"
let g:solarized_visibility = "normal"
let g:solarized_termcolors=256
" let g:solarized_termcolors=16
let g:solarized_termtrans = 1
" colorscheme solarized

colorscheme jellybeans
if exists("$TERM_PROGRAM") && $TERM_PROGRAM == 'iTerm.app'
  if exists("$ITERM_PROFILE")
    if $ITERM_PROFILE == 'Monokai'
      colorscheme monokai
    elseif $ITERM_PROFILE == 'Default'
      " colorscheme inkpot
      " colorscheme badwolf
    endif
  endif
endif

