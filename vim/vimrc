" prevent airline loading before my colorscheme
colorscheme jellybeans-stripped
let g:airline_theme='jellybeans'
if has('python3')
  silent! python3 1
endif
function! FindOrCreate(dir)
  if !isdirectory(expand(a:dir))
    call mkdir(expand(a:dir), "p")
  endif
endfunction

" Deal with single home/multi-arch systems
let plugged_directory = ""
if exists("$ARCH")
  let plugged_directory = $ARCH
elseif exists("$LMOD_arch")
  let plugged_directory = $LMOD_arch
elseif (!has("macunix")) && (!has("win64"))
  let plugged_directory = substitute(system("uname -m"), '[ \n]\+$', '', '')
endif
let plugged_directory = expand("~/.cache/vim-plugged/" . plugged_directory)
if !isdirectory(plugged_directory)
  echo('fetching plug for initial install')
  call system('curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim')
  call system('mkdir -p ' . plugged_directory)
endif

call plug#begin(plugged_directory)

" Bundle 'Shougo/vimproc.vim'
" Plug 'Shougo/vimproc.vim' , { 'do' : 'make'}

"split management
Plug 'wesQ3/vim-windowswap'
let g:windowswap_map_keys = 0 "prevent default bindings
nnoremap <silent> <leader>wy :call WindowSwap#MarkWindowSwap()<CR>
nnoremap <silent> <leader>wp :call WindowSwap#DoWindowSwap()<CR>
nnoremap <silent> <leader>ws :call WindowSwap#EasyWindowSwap()<CR>



"Mail search
" Plug 'daisuzu/unite-notmuch'
" Plug 'diefans/notmuch-vim'

" let g:bracketed_paste_tmux_wrap=0
" Plug 'ConradIrwin/vim-bracketed-paste'

"colorschemes
" Plug 'tomasr/molokai'
" Plug 'sjl/badwolf'
" Plug 'Solarized'
" Plug 'github-theme'
" Plug 'crusoexia/vim-monokai'
" Plug 'nanotech/jellybeans.vim' " in base repo now

Plug 'greymd/oscyank.vim'  " clipboard support for xterm-type terms

" Plug 'luochen1990/rainbow' " rainbow parens and braces etc.

" Render man pages in vim
Plug 'vim-utils/vim-man'

" Plug 'dhruvasagar/vim-table-mode'

"visual
"Plug 'Powerline'
"powerline not working, light alternative?
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
" Plug 'tomtom/quickfixsigns_vim'
" Plug 'bling/vim-bufferline'
Plug 'edkolev/tmuxline.vim'


" if executable('task')
"   Plug 'blindFS/vim-taskwarrior'
" endif

Plug 'junegunn/vim-peekaboo'

" support for live wrapping
Plug 'reedes/vim-pencil', { 'for': 'tex'}

" ==== filetype handlers, highlighting etc ====
Plug 'sheerun/vim-polyglot' " pulls in syntax for almost everything
let g:polyglot_disabled = ['latex', 'markdown']
Plug 'chrisbra/vim-zsh'
let g:zsh_fold_enable = 1
Plug 'lervag/vimtex'
let g:vimtex_view_method='skim'
let g:vimtex_syntax_minted = [
      \ {
      \   'lang' : 'c',
      \ },
      \ {
      \   'lang' : 'fortran',
      \   'environments' : ['ompfPragma'],
      \ },
      \ {
      \   'lang' : 'cpp',
      \   'environments' : ['ompcPragma', 'boxedcode', 'cppcode', 'cppcode_test'],
      \ },
      \ {
      \   'lang' : 'python',
      \   'ignore' : [
      \     'pythonEscape',
      \     'pythonBEscape',
      \     ],
      \ }
      \]
Plug 'tpope/vim-markdown'
let g:markdown_fenced_languages = ['html', 'python', 'bash=sh', "c", "c++=cpp", "latex=tex", "wdiff", "diff"]
Plug 'tpope/vim-apathy'
Plug 'tpope/vim-tbone'

function! InGui()
  return has("gui_running") || exists("g:gui_oni") || exists("neovim_dot_app") || has("gui_vimr")
endfunction


Plug 'mrtazz/DoxygenToolkit.vim'
"link handler
Plug 'vim-scripts/utl.vim' " execute URLs
" not in polyglot - cool csv highlighting
Plug 'chrisbra/csv.vim'
" CSupport plugin: XXX: reacts badly with several others
" Plug 'c.vim'
" org-mode
" Plug 'jceb/vim-orgmode'
" Plug 'dhruvasagar/vim-dotoo' " not really working...

" date incrementing with ^a and so-forth
Plug 'tpope/vim-speeddating'

"tmux integration
Plug 'vim-scripts/vimux'

if ! has('win32')
  function! BuildYCM(info)
    " info is a dictionary with 3 fields
    " - name:   name of the plugin
    " - status: 'installed', 'updated', or 'unchanged'
    " - force:  set on PlugInstall! or PlugUpdate!
    if a:info.status != 'unchanged'
      !./install.py --clang-completer
    endif
  endfunction
  Plug 'Valloric/YouCompleteMe', { 'do': function('BuildYCM') }
endif

" if has('nvim')
"   Plug 'Shougo/deoplete.nvim', { 'do': ':UpdateRemotePlugins' }
" else
"   Plug 'Shougo/deoplete.nvim'
"   Plug 'roxma/nvim-yarp'
"   Plug 'roxma/vim-hug-neovim-rpc'
" endif
" let g:deoplete#enable_at_startup = 1
" Plug 'zchee/deoplete-clang'
" let g:deoplete#sources#clang#libclang_path = '/usr/local//Cellar/llvm/6.0.0/lib/libclang.dylib'
" Plug 'zchee/deoplete-jedi'
" Plug 'zchee/deoplete-zsh'

Plug 'Shougo/neco-vim' " add vim completion to ycm or deoplete

"bindings

"shell/terminal emulation

"file management
" Plug 'xolox/vim-misc'
" Plug 'xolox/vim-notes'
Plug 'vimwiki/vimwiki'
let wiki = {}
let wiki.path = expand('~/projects/vimwiki/')
let wiki.syntax = 'markdown'
let wiki.ext = '.md'
let wiki.nested_syntaxes = {'python': 'python', 'c++': 'cpp', 'c': 'c'}
let tasks = {}
let tasks.path = expand('~/projects/todo/')
let tasks.syntax = 'vimwiki'
let tasks.ext = '.wiki'
let tasks.nested_syntaxes = {'python': 'python', 'c++': 'cpp', 'c': 'c'}
let g:vimwiki_list = [wiki, tasks]
let g:vimwiki_global_ext=0
let g:vimwiki_folding=1
"outliner checkboxes
augroup filetype_vimwiki
  autocmd!
  au FileType vimwiki nmap <Leader>we <Plug>VimwikiSplitLink
  au FileType vimwiki nmap <Leader>wf <Plug>VimwikiFollowLink
  au FileType vimwiki nmap <Leader>wq <Plug>VimwikiVSplitLink
augroup END

" nasty deps, only works with vimwiki syntax not markdown for now,
" cool, but currently not quite what I want I think
" Plug 'tbabej/taskwiki'

Plug 'junegunn/fzf', { 'dir': plugged_directory . '/fzf', 'do': './install --all' }
Plug 'junegunn/fzf.vim'
if(has("python3"))
  Plug 'Shougo/denite.nvim'
  " Plug 'ozelentok/denite-gtags'
  Plug 'nixprime/cpsm'
else
  Plug 'Shougo/unite.vim'
Plug 'Shougo/unite-ssh'
" Plug 'hewes/unite-gtags'
Plug 'tsukkee/unite-tag'
endif
" Plug 'Shougo/vimfiler.vim'
Plug 'Shougo/neoyank.vim' " provides history/yank unite source
" Plug 'vim-scripts/gtags.vim'
Plug 'ludovicchabant/vim-gutentags'
" let g:gutentags_ctags_tagfile = ".git/tags" " causes relative oddness
" These are nice, but they are *way* too slow
" Plug 'xolox/vim-misc'
" Plug 'xolox/vim-easytags'
Plug 'Shougo/neomru.vim'

" if (! exists("g:gui_oni"))
"   "ctrlp
"   Plug 'kien/ctrlp.vim'
"   let g:ctrlp_working_path_mode = 'ra'
"   let g:ctrlp_extensions = ['tag', 'buffertag', 'quickfix', 'dir', 'rtscript',
"         \ 'undo', 'line', 'changes', 'mixed', 'bookmarkdir']
"   " let g:ctrlp_extensions = ['tag', 'buffertag', 'quickfix', 'changes', 'mixed', 'bookmarkdir']
" endif

Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-vinegar'
Plug 'tpope/vim-rhubarb'

" cmdline-mode mappings
Plug 'tpope/vim-rsi'
let g:rsi_no_meta=1
noremap!        <M-b> <S-Left>
noremap!        <M-d> <C-O>dw
cnoremap        <M-d> <S-Right><C-W>
noremap!        <M-BS> <C-W>
noremap!        <M-f> <S-Right>
" Plug 'critiqjo/husk-x.vim'

" Plug 'airblade/vim-gitgutter'

Plug 'nathanaelkane/vim-indent-guides'
let g:indent_guides_start_level = 2
let g:indent_guides_guide_size = 1
let g:indent_guides_enable_on_vim_startup = 1

" Plug 'terryma/vim-multiple-cursors'


" Plug 'Raimondi/delimitMate'
Plug 'tpope/vim-surround'
Plug 'tommcdo/vim-exchange'
Plug 'SirVer/ultisnips'
" Snippets are separated from the engine. Add this if you want them:
Plug 'honza/vim-snippets'
" Plug 'Lokaltog/vim-easymotion'
" map <Leader>e <Plug>(easymotion-prefix)
Plug 'majutsushi/tagbar', { 'on': 'TagbarToggle'}
Plug 'Chiel92/vim-autoformat'
" Plug 'sjl/gundo.vim' " replaced with undotree
Plug 'mbbill/undotree'
Plug 'tpope/vim-repeat'
Plug 'vim-scripts/visualrepeat'
"new alignment plugin, CR from visual mode to use
Plug 'junegunn/vim-easy-align'
Plug 'tpope/vim-abolish'
" Plug 'tpope/vim-pastie'
"Unix command aliases, Chmod and company
Plug 'tpope/vim-eunuch'
Plug 'tpope/vim-unimpaired'
Plug 'tpope/vim-dispatch'
Plug 'radenling/vim-dispatch-neovim'
Plug 'tomtom/tcomment_vim'

"Word highlighting for possible but uncertain errors
Plug 'reedes/vim-wordy'

Plug 'tpope/vim-vinegar'
nnoremap <silent> _ :Rexplore<cr>

Plug 'tpope/vim-sensible'

call plug#end()

let mapleader      = ','
let maplocalleader = ','

autocmd FileType vim setlocal omnifunc=helpers#Vim_complete

" Alignment mapping to enter in visual mode
vmap <CR> <Plug>(EasyAlign)

" let $PYTHONPATH .= ":~/.vim/included/ropevim"
" source ~/.vim/included/ropevim/ropevim.vim

" Prompt for a command to run
map <Leader>vp :VimuxPromptCommand<CR>

" Open pane
map <Leader>vo :call VimuxOpenPane()<CR>

" Run last command executed by VimuxRunCommand
map <Leader>vl :VimuxRunLastCommand<CR>

" Inspect runner pane
map <Leader>vi :VimuxInspectRunner<CR>

" Close vim tmux runner opened by VimuxRunCommand
map <Leader>vq :VimuxCloseRunner<CR>

" Interrupt any command running in the runner pane
map <Leader>vx :VimuxInterruptRunner<CR>



"Unite and denite
let  g:notes_directories = ['~/Projects/notes']
if( ! has("python3")) " using unite
  let g:unite_data_directory = '~/.vim/unite'
  " let g:unite_source_bookmark_directory = '~/.vim/unite-bookmarks'
  let g:unite_source_history_yank_enable = 1
  let g:unite_source_grep_max_candidates = 500
  call unite#filters#matcher_default#use(['converter_relative_word', 'matcher_fuzzy'])
  call unite#filters#sorter_default#use(['sorter_rank'])
  call unite#custom#profile('files', 'filters', 'sorter_rank')
  call unite#custom#source('buffer,file,file_rec,file_rec/async', 'sorters', 'sorter_selecta')
  call unite#custom#source('buffer,file,file_rec,file_rec/async', 'matchers',['converter_relative_word', 'matcher_fuzzy'])
  nnoremap <leader>ur  :<C-u>Unite -start-insert file_rec/async:!<CR>
  nnoremap <leader>ub  :<C-u>Unite buffer        file_mru bookmark<CR>
  nnoremap <leader>uB  :<C-u>Unite bookmark<CR>
  nnoremap <leader>uY  :<C-u>Unite history/yank<CR>
  nnoremap <leader>uf  :<C-u>Unite -start-insert file<CR>
  nnoremap <leader>un  :<C-u>Unite -start-insert file_rec:~/Projects/notes/<CR>
  nnoremap <leader>ug  :<C-u>Unite grep:.<CR>
  nnoremap <leader>uG  :<C-u>Unite grep:.:-i<CR>
  nnoremap <leader>utc :<C-u>Unite gtags/context<CR>
  nnoremap <leader>utr :<C-u>Unite gtags/ref<CR>
  nnoremap <leader>utd :<C-u>Unite gtags/def<CR>
  nnoremap <leader>utg :<C-u>Unite gtags/grep<CR>
  nnoremap <leader>utf :<C-u>Unite gtags/file<CR>
  nnoremap <leader>utC :<C-u>Unite gtags/completion<CR>
  augroup UniteTagsRemap
    autocmd BufEnter *
          \   if empty(&buftype)
          \|      nnoremap <buffer> <C-]> :<C-u>UniteWithCursorWord -immediately tag<CR>
          \|  endif
  augroup END
else
  call denite#custom#alias('source', 'file_rec/git', 'file_rec')
  call denite#custom#var('file_rec/git', 'command',
        \ ['git', 'ls-files', '-co', '--exclude-standard'])
  " nnoremap <silent> <leader>ur :<C-u>Denite
  "       \ `finddir('.git', ';') != '' ? 'file_rec/git' : 'file_rec'`<CR>
  function! Find_ur_dir()
    let l:target=fnamemodify(resolve(expand('%:p')), ':p:h')
    let l:git=finddir('.git',l:target . ';')
    if l:git != ''
      return fnamemodify(l:git, ':h')
    else
      return '.'
    endif
  endfunction

  nnoremap <silent> <leader>ur :<C-u>Denite `"file_rec:" . Find_ur_dir()`<CR>
  " nnoremap <silent> <leader>ur :<C-u>Denite file_rec<CR>
  " function! Enter_and_open(dirs)
  "   echo a:dirs
  "   echo a:dirs[0]
  "   " cd a:dirs[0]
  "   " Denite "file/rec:" . a:dirs[0]
  " endfunction
  " call denite#custom#action('directory', 'enter_and_open',
  "       \ {context -> Enter_and_open(context['targets'])})

  nnoremap <leader>ub  :Denite buffer file_mru<CR>
  nnoremap <leader>uY  :Denite neoyank<CR>
  nnoremap <leader>uf  :Denite `"file_rec:" . expand("%:p:h")`<CR>
  nnoremap <leader>up  :Denite `"file::" . expand("~/projects")`<CR>
  nnoremap <leader>un  :Denite file_rec:~/Projects/notes/<CR>
  nnoremap <leader>ug  :Denite grep:.<CR>
  nnoremap <leader>uG  :Denite grep:.:-i<CR>
  nnoremap <leader>ul  :Denite line<CR>
  nnoremap <leader>uT  :Denite outline<CR>
  nnoremap <leader>ut  :Denite tag<CR>
  nnoremap <leader>u]  :DeniteCursorWord -immediately-1 -mode=normal tag<CR>
  " nnoremap <leader>utc :DeniteCursorWord -buffer-name=gtags_context -immediately-1 -mode=normal gtags_context<CR>
  " nnoremap <leader>utr :DeniteCursorWord -buffer-name=gtags_ref -immediately-1 -mode=normal gtags_ref<CR>
  " nnoremap <leader>utd :DeniteCursorWord -buffer-name=gtags_def -immediately-1 -mode=normal gtags_def<CR>
  " nnoremap <leader>utg :DeniteCursorWord -buffer-name=gtags_grep -mode=normal gtags_grep<CR>
  " nnoremap <leader>utf :Denite           -buffer-name=gtags_file -mode=normal gtags_file<CR>
  " nnoremap <leader>utC :Denite           -buffer-name=gtags_completion -mode=normal gtags_completion<CR>
  augroup DeniteTagsRemap
    autocmd BufEnter *
          \   if empty(&buftype)
          \|      nnoremap <buffer> <C-]> :<C-u>DeniteCursorWord -immediately-1 tag<CR>
          \|  endif
  augroup END
  call denite#custom#map('normal', 'v', '<denite:do_action:vsplit>')

  if executable('ag')
    " Change file_rec command.
    call denite#custom#var('file_rec', 'command',
          \ ['ag', '--follow', '--nocolor', '--nogroup', '-g', ''])

    " Ag command on grep source
    call denite#custom#var('grep', 'command', ['ag'])
    call denite#custom#var('grep', 'default_opts',
          \ ['-i', '--vimgrep'])
    call denite#custom#var('grep', 'recursive_opts', [])
    call denite#custom#var('grep', 'pattern_opt', [])
    call denite#custom#var('grep', 'separator', ['--'])
    call denite#custom#var('grep', 'final_opts', [])
  elseif executable('rg')
    " For ripgrep
    " Note: It is slower than ag
    call denite#custom#var('file_rec', 'command',
          \ ['rg', '--files', '--glob', '!.git', ''])

    " Ripgrep command on grep source
    call denite#custom#var('grep', 'command', ['rg'])
    call denite#custom#var('grep', 'default_opts',
          \ ['--vimgrep', '--no-heading'])
    call denite#custom#var('grep', 'recursive_opts', [])
    call denite#custom#var('grep', 'pattern_opt', ['--regexp'])
    call denite#custom#var('grep', 'separator', ['--'])
    call denite#custom#var('grep', 'final_opts', [])

    " For Pt(the platinum searcher)
    " NOTE: It also supports windows.
  elseif executable('pt')
    call denite#custom#var('file_rec', 'command',
          \ ['pt', '--follow', '--nocolor', '--nogroup',
          \  (has('win32') ? '-g:' : '-g='), ''])

    " Pt command on grep source
    call denite#custom#var('grep', 'command', ['pt'])
    call denite#custom#var('grep', 'default_opts',
          \ ['--nogroup', '--nocolor', '--smart-case'])
    call denite#custom#var('grep', 'recursive_opts', [])
    call denite#custom#var('grep', 'pattern_opt', [])
    call denite#custom#var('grep', 'separator', ['--'])
    call denite#custom#var('grep', 'final_opts', [])
  endif
  if executable('fd')
    call denite#custom#var('file_rec', 'command',
          \ ['fd', '--type', 'f', '--follow', '--color', 'never', ''])
  endif

  " Change mappings.
  call denite#custom#map(
        \ 'insert',
        \ '<C-j>',
        \ '<denite:move_to_next_line>',
        \ 'noremap'
        \)
  call denite#custom#map(
        \ 'insert',
        \ '<C-k>',
        \ '<denite:move_to_previous_line>',
        \ 'noremap'
        \)
  call denite#custom#map(
        \ 'insert',
        \ '<C-a>',
        \ '<denite:move_caret_to_head>',
        \ 'noremap'
        \)
  call denite#custom#map(
        \ 'insert',
        \ '<C-e>',
        \ '<denite:move_caret_to_tail>',
        \ 'noremap'
        \)
  call denite#custom#map(
        \ 'insert',
        \ '<A-b>',
        \ '<denite:move_caret_to_one_word_left>',
        \ 'noremap'
        \)
  call denite#custom#map(
        \ 'insert',
        \ '<A-f>',
        \ '<denite:move_caret_to_one_word_right>',
        \ 'noremap'
        \)
  call denite#custom#map(
        \ 'insert',
        \ '<A-BS>',
        \ '<denite:delete_word_before_caret>',
        \ 'noremap'
        \)
  call denite#custom#map(
        \ 'insert',
        \ '<A-d>',
        \ '<denite:delete_word_under_caret>',
        \ 'noremap'
        \)
  call denite#custom#map(
        \ 'insert',
        \ '<Up>',
        \ '<denite:move_to_previous_line>',
        \ 'noremap'
        \)
  call denite#custom#map(
        \ 'insert',
        \ '<Down>',
        \ '<denite:move_to_next_line>',
        \ 'noremap'
        \)
  call denite#custom#map(
        \ 'insert',
        \ '<S-Up>',
        \ '<denite:assign_previous_matched_text>',
        \ 'noremap'
        \)
  call denite#custom#map(
        \ 'insert',
        \ '<S-Down>',
        \ '<denite:assign_next_matched_text>',
        \ 'noremap'
        \)

  " Change matchers.
  call denite#custom#source(
        \ 'file_mru', 'matchers', ['matcher_fuzzy', 'matcher_project_files'])
  call denite#custom#source(
        \ 'file_rec', 'matchers', ['matcher_cpsm'])

  " Change sorters.
  call denite#custom#source(
        \ 'file_rec', 'sorters', ['sorter_sublime'])


  " Define alias
  call denite#custom#alias('source', 'file_rec/git', 'file_rec')
  call denite#custom#var('file_rec/git', 'command',
        \ ['git', 'ls-files', '-co', '--exclude-standard'])

  " Change default prompt
  " call denite#custom#option('default', 'prompt', '>')

  " Change ignore_globs
  call denite#custom#filter('matcher_ignore_globs', 'ignore_globs',
        \ [ '.git/', '.ropeproject/', '__pycache__/',
        \   'venv/', 'images/', '*.min.*', 'img/', 'fonts/'])
endif

command! -bang -nargs=* Ag
      \ call fzf#vim#ag(<q-args>,
      \                 <bang>0 ? fzf#vim#with_preview('up:60%')
      \                         : fzf#vim#with_preview('right:50%:hidden', '?'),
      \                 <bang>0)

command! FZFMru call fzf#run({
\ 'source':  reverse(s:all_files()),
\ 'sink':    'edit',
\ 'options': '-m -x +s',
\ 'down':    '40%' })

function! s:all_files()
  return extend(
  \ filter(copy(v:oldfiles),
  \        "v:val !~ 'fugitive:\\|NERD_tree\\|^/tmp/\\|.git/'"),
  \ map(filter(range(1, bufnr('$')), 'buflisted(v:val)'), 'bufname(v:val)'))
endfunction

function! Files_with_ur_dir()
  let l:dir = Find_ur_dir()
  echo l:dir
  :execute 'Files ' . l:dir
endfunction
" fzf version of the mappings, experimental
nnoremap <silent> <leader>fr  :call Files_with_ur_dir()<CR>
nnoremap <silent> <leader>fb  :History<CR>
nnoremap <silent> <leader>fs  :GFiles?<CR>
nnoremap <silent> <leader>fn  :Files ~/Projects/notes/<CR>
nnoremap <silent> <leader>fg  :call helpers#AgWithParam()<CR>
nnoremap <silent> <leader>fl  :BLines<CR>
nnoremap <silent> <leader>fL  :Lines<CR>
nnoremap <silent> <leader>fT  :BTags<CR>
nnoremap <silent> <leader>ft  :Tags<CR>
nnoremap <silent> <leader>f]  :call TagsWithCword()<CR>

let include_paths = ['/opt/local/include','/usr/local/include','/usr/include','/Developer/Headers',fnamemodify('~/programs/include',':p')]
let &path= join(['.', '', './include'] + include_paths, ',')
let g:unite_source_gtags_project_config = {
      \ '_':                   { 'gtags_libpath': include_paths }
      \ }



let g:global_objdir=$HOME . "/.cache/global-obj"
call FindOrCreate(g:global_objdir)
" For regular tags
let tag_file = g:global_objdir . "/tags"
set tags=./tags;.git/tags;,tags


if executable('rg')
  let unite_ignores = ["!CMakeFiles",
        \"!*.dSYM",
        \"!*.dat",
        \"!*.pdf",
        \"!*.bib"]
  let unite_globs = []
  for ig in unite_ignores
    call add(unite_globs, "--glob '" . ig . "'")
  endfor
  " Use rg in unite grep source.
  let g:unite_source_grep_command = 'rg'
  let g:unite_source_grep_default_opts = ' --smart-case -n --no-heading --color never --no-messages ' .
        \ join(unite_globs) . ' -e '
  let g:unite_source_grep_separator = "" "avoid having unite add '--' where it doesn't go
  let g:unite_source_grep_recursive_opt = ''
  " The empty perens set the pattern, all files should match
  let unite_globs2 = []
  for ig in unite_ignores
    call add(unite_globs2, '--glob')
    call add(unite_globs2, ig)
  endfor
  let g:unite_source_rec_async_command = ['rg', '--color', 'never', '--no-heading', '--files'] + unite_globs2
elseif executable('pt')
  " Use pt in unite grep source.
  " https://github.com/monochromegane/the_platinum_searcher
  let g:unite_source_grep_command = 'pt'
  let g:unite_source_grep_default_opts = ' --smart-case --nogroup --nocolor ' .
        \ '--ignore ''*.dat'' --ignore ''*.pdf'' --ignore ''*.bib'' -e '
  let g:unite_source_grep_recursive_opt = ''
  " The empty perens set the pattern, all files should match
  let g:unite_source_rec_async_command = ['pt', '--nocolor', '--nogroup', '-g', ".", ""]
elseif executable('ag')
  " Use ag in unite grep source.
  let g:unite_source_grep_command = 'ag'
  let g:unite_source_grep_default_opts =
        \ '--line-numbers --nocolor --nogroup --hidden ' .
        \ '--ignore ''CMakeFiles'' ' .
        \ '--ignore ''*.dat'' --ignore ''*.pdf'' --ignore ''build*''  '
  let g:unite_source_grep_recursive_opt = ''
  let g:unite_source_rec_async_command = ['ag', '-i', '--nocolor', '--nogroup', '--ignore', 'build*', '--ignore', '.git', '--ignore', '.bzr', '--ignore', 'node_modules', '--hidden', '-g', ""]
else
  let g:unite_source_rec_find_args = ['-path', '*/.git/*', '-prune', '-o', '-path', '*/build*/*', '-prune', '-o', '-print']
endif

"YouCompleteMe
nnoremap <leader>yg :YcmCompleter GoTo<CR>
nnoremap <leader>yG :YcmCompleter GoToImprecise<CR>
nnoremap <leader>yf :YcmCompleter FixIt<CR>
nnoremap <leader>yt :YcmCompleter GetType<CR>
nnoremap <leader>yp :YcmCompleter GetParent<CR>
nnoremap <leader>yd :YcmCompleter GetDoc<CR>

let g:ycm_semantic_triggers =  {
      \ 'c' : ['_'],
      \ 'vim' : ['_'],
      \}
let g:ycm_complete_in_strings = 1
let g:ycm_extra_conf_vim_data=['&filetype']
let g:ycm_global_ycm_extra_conf = '~/.ycm_extra_conf.py'
let g:ycm_extra_conf_globlist = ['~/Dropbox/*','~/projects/*','~/Projects/*']
let g:ycm_autoclose_preview_window_after_insertion = 1
" let g:ycm_key_invoke_completion = '<C-S-Space>'
let g:ycm_key_invoke_completion = '<C-Space>'
" let g:ycm_key_invoke_completion = '<Tab>'
let g:ycm_key_list_select_completion = ['<C-n>', '<Down>', '<Tab>']
let g:ycm_key_list_previous_completion = ['<C-p>', '<Up>', '<S-Tab>']
let g:ycm_min_num_of_chars_for_completion = 99
let g:ycm_min_num_identifier_candidate_chars = 99

let g:UltiSnipsExpandTrigger="<c-j>"
inoremap <S-tab> <Esc>:call UltiSnips_ListSnippets()<CR>

"syntax/visual options
let g:vimsyn_folding = 'aflP'
let g:vimsyn_embed = 'lP'
let g:sh_fold_enabled= 7 "    (enable all folding)
set vb
set t_vb=
" syn on
set ruler
set nowrap

set winaltkeys=no
set virtualedit=block,insert

set suffixes+=.com,.class,.dll,.exe,.o,.so
set suffixes+=.dmg,.iso,.jar,.rar,.tar,.zip
set suffixes+=.DS_Store,.DS_Store?,._*,.Spotlight-V100,ehthumbs.db,Thumbs.db
set suffixes+=.swp,~
set suffixes+=.aux,.lot,.lof,.pyg,.toc
set suffixes+=.pdf,.eps,.epsi,.png,.jpg,.svg
set suffixes+=.log,.out,.bbl,.blg,.fls,.fdb_latexmk,.synctex.gz,.aux,.latexmain
" set suffixes+=*.xls,*.xlsx,*.ppt,*.pptx,*.doc,*.docx,*.graffle

"additional buffer types
augroup extra_filetypes
  autocmd!
  au BufNewFile,BufRead *.cu           set      ft=cuda
  au BufNewFile,BufRead *.cuh          set      ft=cuda
  au BufNewFile,BufRead *.cl           set      ft=opencl
  au BufNewFile,BufRead *.go           set      ft=go
  au FileType           go             setlocal formatprg=gofmt
  au BufRead            COMMIT_EDITMSG set      backupcopy=no
  au BufNewFile,BufRead *.txt          set      ft=txt
  au BufNewFile,BufRead CMakeLists.txt set      ft=cmake
  au BufNewFile,BufRead CMakeCache.txt set      ft=cmake
augroup END

" Save a file as root (,W)
noremap <leader>W :w !sudo tee % > /dev/null<CR>


"automatic formatting options
set textwidth=80
augroup git_messages
  autocmd!
  au FileType gitcommit setlocal textwidth=72
augroup END
set formatoptions=crq
" set fo-=t
" au FileType tex set formatoptions+=a
augroup text_formatting
  autocmd!
  au FileType txt setlocal formatoptions+=t
  au FileType txt setlocal formatexpr=cindent
augroup END
"set formatoptions+=a

"hilighting
let python_highlight_all = 1
"there is no local value for fp, must set other languages to use cindent
"manually

call helpers#Map_for_all("<C-k>", ":Autoformat<CR>", 1, 0, 0)


" use ascii symbols instead of unicode, expariment
" let g:airline_symbols_ascii = 1
" let g:airline#extensions#tmuxline#enabled = 1
" let g:airline#extensions#bufferline#enabled = 1
" let g:airline#extensions#branch#enabled = 1
" let g:airline#extensions#tagbar#enabled = 1
" let g:airline#extensions#tagbar#flags = 'f'
" let g:airline#extensions#quickfix#enabled = 1
" let g:airline#extensions#branch#displayed_head_limit = 10
" let g:airline#extensions#csv#enabled = 1
let g:airline_highlighting_cache = 1
let g:airline#extensions#whitespace#enabled=0
" let g:airline_extensions = ["tmuxline","branch","tagbar","quickfix","denite","csv","netrw","term","vimtex"]
let g:airline_extensions = ["tmuxline","branch","tagbar","quickfix","denite","csv","netrw","term","vimtex","undotree","windowswap","gutentags","fugitiveline"]
set timeoutlen=300
set ttimeoutlen=10

if InGui()
  set guioptions=egmt
  if has("gui_macvim")
    "CRITICAL option, allows alt-based key-bindings to work in macvim
    set macmeta
    set transparency=10
    " set gfn=Courier\ New:h11.00
    " set gfn=ProFontX:h9.00
    " expariment to get italic monospace variant with full powerline support
    set gfn=Hack\ Regular\ Nerd\ Font\ Complete:h10
    set antialias
    set fuopt=maxvert,maxhorz
  elseif has("gui_gtk2")
    set guifont=Terminus\ 8
  elseif has("x11")
    " Also for GTK 1
    set guifont=-misc-fixed-medium-r-normal-*-10-*-*-*-c-*-iso8859-15
  endif

  if exists("neovim_dot_app") || has("gui_vimr") " VimR thinks it isn't a gui..?
    let g:terminal_color_0 = '#2e3436'
    let g:terminal_color_1 = '#cc0000'
    let g:terminal_color_2 = '#4e9a06'
    let g:terminal_color_3 = '#c4a000'
    let g:terminal_color_4 = '#3465a4'
    let g:terminal_color_5 = '#75507b'
    let g:terminal_color_6 = '#0b939b'
    let g:terminal_color_7 = '#d3d7cf'
    let g:terminal_color_8 = '#555753'
    let g:terminal_color_9 = '#ef2929'
    let g:terminal_color_10 = '#8ae234'
    let g:terminal_color_11 = '#fce94f'
    let g:terminal_color_12 = '#729fcf'
    let g:terminal_color_13 = '#ad7fa8'
    let g:terminal_color_14 = '#00f5e9'
    let g:terminal_color_15 = '#eeeeec'
  endif
endif

"Normalize backspace
set t_kb=
call helpers#Map_for_all("", "<BS>", 1, 1)

if &term =~ "screen.*" "screen configurations
  if &term =~ "screen.*-bce"
    set term=screen-256color
  endif
  "set ttymouse=xterm "falls back to xterm for unsupported terminal type
  set t_ku=OA
  set t_kd=OB
  set t_kr=OC
  set t_kl=OD
  set t_@7=OF
  set t_kh=[1~

  call helpers#Map_for_all("<Esc>[C", "<Right>", 1, 1)
  call helpers#Map_for_all("<Esc>[D", "<Left>", 1, 1)
  call helpers#Map_for_all("<Esc>[A", "<Up>", 1, 1)
  call helpers#Map_for_all("<Esc>[B", "<Down>", 1, 1)

  call helpers#Map_for_all("<Esc>[4~", "<End>", 1, 1)
  call helpers#Map_for_all("<Esc>[1~", "<Home>", 1, 1)

  call helpers#Map_for_all("<Esc>0F", "<End>", 1, 1)
  call helpers#Map_for_all("<Esc>OH", "<Home>", 1, 1)
  call helpers#Map_for_all("<Esc>[F", "<End>", 1, 1)
  call helpers#Map_for_all("<Esc>[H", "<Home>", 1, 1)
endif


" tComment extra mappings:
" yank visual before toggle comment
vmap gy ygvgc
" yank and past visual before toggle comment
vmap gyy ygvgc'>gp'.
" yank line before toggle comment
nmap gy yygcc
" yank and paste line before toggle comment and remember position
" it works both in normal and insert mode
" Use :t-1 instead of yyP to preserve registers
nmap gyy mz:t-1<cr>gcc`zmz
" imap gyy <esc>:t-1<cr>gCcgi
vmap gcc gc

"map <Leader>x <plug>NERDCommenterToggleComment
" Follow links with ,o
nnoremap <Leader>o :Utl ol<CR>
let g:utl_cfg_hdl_scm_http_system = 'silent !open "%u"'
let g:utl_cfg_hdl_scm_http = 'silent !open "%u"'
let g:utl_cfg_hdl_mt_generic = 'silent !open "%p"'

"editing behavior
set history=10000
set backspace=2
" set softtabstop=2 "used to favor the gnu style, getting used to K&R @ 4 spaces
" set shiftwidth=2
set softtabstop=2
set shiftwidth=2
set expandtab
set hlsearch
set incsearch
set ignorecase
set smartcase
set modeline
set modelines=5
" Optimize for fast terminal connections
set ttyfast
" Use UTF-8 without BOM
" set encoding=utf-8 nobomb " covered by sensible
" Centralize backups, swapfiles and undo history, make dropbox happy!
call FindOrCreate("~/.vim-backups")
set backupdir=~/.vim-backups
call FindOrCreate("~/.vim-swaps")
set directory=~/.vim-swaps//
if exists("&undodir")
  call FindOrCreate("~/.vim-undo")
  set undodir=~/.vim-undo
endif
" Enable per-directory .vimrc files and disable unsafe commands in them
set exrc
set secure
" Highlight current line
" set cursorline
" set cursorcolumn
augroup cursorhighlight
  au!
  autocmd BufEnter *
        \   if (&buftype == 'nofile')
        \|      set nocursorline
        \|      set nocursorcolumn
        \|  endif
augroup END
" Show “invisible” characters
" set lcs=tab:▸\ ,trail:·,eol:¬,nbsp:_
" set lcs=tab:▸\ ,trail:·,nbsp:_
highlight WhitespaceEOL ctermbg=red guibg=red
match WhitespaceEOL /\s\+$/
set list
" Always show status line
set laststatus=2
" Don’t reset cursor to start of line when moving around.
set nostartofline
" Show the cursor position
set ruler
" Don’t show the intro message when starting Vim
set shortmess=atI
" Show the current mode
set showmode
" Show the (partial) command as it’s being typed
" nice, but slow
" set showcmd
" Start scrolling three lines before the vertical window border
set scrolloff=3
" Start scrolling three lines before the horizontal window border
set sidescrolloff=3

nnoremap <silent> <Leader>ml :call AppendModeline()<CR>


"diff behavior
set diffopt+=iwhite

"indent
set autoindent
set smartindent

"c/c++ options
augroup c_setup
  autocmd!
  au FileType c set foldmethod=syntax
augroup END


augroup text_setup
  autocmd!

  au FileType txt set textwidth=80
  au FileType txt setlocal spell spelllang=en_us
  au FileType help setlocal nospell spelllang=en_us
augroup END

"build system options
" Command Make will call make and then cwindow which
" opens a 3 line error window if any errors are found.
" if no errors, it closes any open cwindow.
" command! -nargs=* Make make <args> | cwindow 3
" command! -nargs=* Scons scons <args> | cwindow 3
nnoremap <Leader>m :Make<cr>

augroup build_autos
  autocmd!
  au BufRead,BufNewFile SConstruct set filetype=python

  au FileType make inoremap <buffer> <tab> <tab>
  au FileType make setlocal softtabstop=0
  au FileType make setlocal shiftwidth=8
  au FileType make setlocal noexpandtab
  au FileType make setlocal noautoindent
  au FileType make setlocal nosmartindent
augroup END

function! Clang_rename_string(new_name)
  "Save window state
  let winview=winsaveview()

  "Rename symbol
  exe "1,$!clang-rename -offset " . (line2byte( line('.'))+col('.')) . " -new-name='" . a:new_name . "' %"
  "clang-rename -offset 4156 -new-name=do_other_stuff_for_some_reason -pl -pn

  "Recall window state
  call winrestview(winview)
endfunction

function! Clang_rename()
  call inputsave()
  let name = input('Enter name: ')
  call inputrestore()
  call Clang_rename_string(name)
endfunction



"general key remappings
nmap Y y$

call helpers#Map_for_all("<C-c>","<Esc><Esc>", 1, 1)
inoremap kj <Esc><Esc>

map <S-Z><S-S> :up<CR>


if ! InGui()
  "new experiment, using xterm clipboard escapes for copy portability, no paste
  "(I think..?)

  noremap <silent> <A-c>        :Oscyank<CR>
  noremap <silent> <Esc>c       :Oscyank<CR>

  if has('macunix')
    " should be handled in tmux now...
    " let tmux_reattach_prefix="reattach-to-user-namespace"
    " if (! executable(tmux_reattach_prefix))
    "   let tmux_reattach_prefix=glob("~/Dropbox/config/tmux-MacOSX-pasteboard/reattach-to-user-namespace")
    " elseif (! filereadable(tmux_reattach_prefix))
    "   let tmux_reattach_prefix=glob("~/Projects/config-sync/tmux-MacOSX-pasteboard/reattach-to-user-namespace")
    " endif

    "paste from pbpaste as paste normally works, from the current cursor position
    function! Paste_proper()
      " let @p=system(g:tmux_reattach_prefix . " pbpaste")
      let @p=system(g:tmux_reattach_prefix . " pbpaste")
      execute 'normal "pp'
    endfunction
    vmap <silent> <A-v>        dh:call Paste_proper()<CR>
    vmap <silent> <Esc>v       dh:call Paste_proper()<CR>
    imap <silent> <A-v>        <Esc>: call Paste_proper()<CR>
    imap <silent> <Esc>v       <Esc>: call Paste_proper()<CR>
    nmap <silent> <A-v>        :call Paste_proper()<CR>
    nmap <silent> <Esc>v       :call Paste_proper()<CR>
  endif

  call helpers#Map_for_all("<Esc>[1;3C", "<End>", 1, 1, 1)
  call helpers#Map_for_all("<Esc>[1;3D", "<Home>", 1, 1, 1)
  call helpers#Map_for_all("<Esc>[1;9D", "<C-Left>", 1, 1, 1)
  call helpers#Map_for_all("<Esc>[1;9C", "<C-Right>", 1, 1, 1)

endif


""tag jump remappings, makes <C-]> list if more than 1, immediate if only 1,
""alt does the same, but in a new vertical split so you can look at both
""together, awesome for looking at function arguments and defs together
" function! Vertical_tag_jump()
"     execute "vert rightb stj " . expand("<cword>")
" endfunction
" map  <C-]>   g<C-]>
" imap  <C-]>  <Esc>g<C-]>
" cmap  <C-]>  g<C-]>

if exists("neovim_dot_app")
  call MacSetOptionAsMeta(1)
endif
" if ! has("gui_running")
"alt
"tab management
call helpers#Map_for_all_meta('t', ":tabnew<CR>", 2, 1, 1)
call helpers#Map_for_all_meta('}', ":tabnext<CR>", 2, 1, 1)
call helpers#Map_for_all_meta('{', ":tabprevious<CR>", 2, 1, 1)
call helpers#Map_for_all_meta('w', ":tabclose<CR>", 2, 1, 1)

"Powerline
set laststatus=2 "keeps the statusbar on
if exists("$TERM_PROGRAM") && $TERM_PROGRAM == 'iTerm.app'
  let g:airline_powerline_fonts = 1
endif

"general options
set grepprg=grep\ -nH\ $*
" Enhance command-line completion
set wildmenu
set wildmode=longest:list,full
set foldmethod=syntax
" set foldcolumn=1 " show fold depth in the gutter
" filetype indent on " covered by sensible
" filetype plugin on

"winmanager
let g:winManagerWindowLayout = "Project|TagList"

"window switching
call helpers#Map_for_all_meta("h", "<C-w>h", 2, 0, 1)
call helpers#Map_for_all_meta("j", "<C-w>j", 2, 0, 1)
call helpers#Map_for_all_meta("k", "<C-w>k", 2, 0, 1)
call helpers#Map_for_all_meta("l", "<C-w>l", 2, 0, 1)
call helpers#Map_for_all_meta("S-h", "<C-w>h", 2, 0, 1)
call helpers#Map_for_all_meta("S-j", "<C-w>j", 2, 0, 1)
call helpers#Map_for_all_meta("S-k", "<C-w>k", 2, 0, 1)
call helpers#Map_for_all_meta("S-l", "<C-w>l", 2, 0, 1)

if has("nvim")
  tnoremap <C-w> <C-\><C-n><C-w>
endif

" let g:vimfiler_as_default_explorer = 1
let g:vimfiler_as_default_explorer = 0

nnoremap <silent> <M-f>      :call helpers#ToggleVExplorer()<CR>
nnoremap <silent> <A-S-f>    :call helpers#ToggleVExplorer()<CR>
nnoremap <silent> <Esc><S-f> :call helpers#ToggleVExplorer()<CR>
nnoremap <silent> <D-F>      :call helpers#ToggleVExplorer()<CR>
nmap     <silent> <F3>       :call helpers#ToggleVExplorer()<CR>
let g:netrw_liststyle = 4
" let g:netrw_home      = '~/.vim'

" clear search, close preview, redraw
nnoremap <silent> <C-L> :pc<CR>:noh<CR><C-L>

" --------------------
" TagList
" --------------------
" F4:  Switch on/off TagList
nnoremap <silent> <F4> :TagbarToggle<CR>
nnoremap <silent> <A-S-t> :TagbarToggle<CR>
nnoremap <silent> <Esc><S-t> :TagbarToggle<CR>
nnoremap <silent> <D-T> :TagbarToggle<CR>

let g:tagbar_autoclose = 1

"mouse options
set mouse=a
"enable wide mouse support for iTerm2 and urxvt, should also work in new xterms
if !has("nvim")
  if has('mouse_sgr')
    set t_RV=
    set ttymouse=sgr
  else
    set ttymouse=xterm2
  endif
endif

" colorscheme solarized
if &term =~ ".*256color.*" || has("gui_running")
  if $COLORTERM == "truecolor"
    set termguicolors
  else
    set t_Co=256
  endif
  " let g:inkpot_black_background=1
  " colorscheme inkpot
endif

" let g:jellybeans_overrides = {
"             \    'background': { 'ctermbg': 'Black' },
"             \}
if !has("gui_running")
  " let g:jellybeans_background_color = "000000"
  " let g:jellybeans_use_lowcolor_black = 1
  " let g:jellybeans_background_color_256="0"
endif

" set background=dark
" let g:solarized_contrast = "high"
let g:solarized_contrast = "normal"
let g:solarized_visibility = "normal"
let g:solarized_termcolors=256
" let g:solarized_termcolors=16
let g:solarized_termtrans = 1
" colorscheme solarized

if exists("$TERM_PROGRAM") && $TERM_PROGRAM == 'iTerm.app'
  if exists("$ITERM_PROFILE")
    if $ITERM_PROFILE == 'Monokai'
      colorscheme monokai
    elseif $ITERM_PROFILE == 'Default'
      " colorscheme inkpot
      " colorscheme badwolf
    endif
  endif
endif

